--- a/trade_system/backtester.py
+++ b/trade_system/backtester.py
@@ def run(self, symbol, interval, lookback):
-        for idx in range(len(df)):
+        for idx in range(len(df)):
             window = df.iloc[:idx+1]
             signal = calculate_signals(window)
             price = window['close'].iloc[-1]
 
-            # Entry logic: só compra se não houver posição aberta
-            if signal == 'BUY' and not position_open:
-                size = self.risk_manager.calculate_position_size(price, window)
-                entry_price = price
-                position_open = True
-                trades.append({'side': 'BUY', 'price': price, 'size': size})
-                continue
+            # Entry logic: só BUY se não houver posição aberta
+            if signal == 'BUY' and not position_open:
+                size = self.risk_manager.calculate_position_size(price, window)
+                entry_price = price
+                position_open = True
+                trades.append({'side': 'BUY', 'price': price, 'size': size})
+                continue
 
-            # Exit logic: só vende se houver posição aberta
-            if signal == 'SELL' and position_open:
-                size = trades[-1]['size']
-                trades.append({'side': 'SELL', 'price': price, 'size': size})
-                position_open = False
-                continue
+            # Exit logic: só SELL se houver posição aberta
+            if signal == 'SELL' and position_open:
+                size = trades[-1]['size']
+                trades.append({'side': 'SELL', 'price': price, 'size': size})
+                position_open = False
+                continue
 
--- a/trade_system/analysis/technical.py
+++ b/trade_system/analysis/technical.py
@@
-import talib
-import numpy as np
+import pandas as pd
+import talib
+import numpy as np
 
 def calculate_signals(df):
-    close = df['close'].values
+    close = df['close'].values
     if len(close) < 21:
         return 'HOLD'
 
@@
-    vol_buy = df.get('volume_buy', pd.Series(0)).sum()
-    vol_sell = df.get('volume_sell', pd.Series(0)).sum()
+    vol_buy = df.get('volume_buy', pd.Series(0)).sum()
+    vol_sell = df.get('volume_sell', pd.Series(0)).sum()
     imbalance = (vol_buy / (vol_buy + vol_sell + 1e-9)) * 100
 
@@
-    # Lógica combinada com thresholds mais robustos
+    # Lógica combinada com thresholds robustos
     if ema_fast > ema_slow and rsi < 30 and imbalance > 80:
         return 'BUY'
     if ema_fast < ema_slow and rsi > 70 and imbalance < 20:
         return 'SELL'
@@
-    return 'HOLD'
+    return 'HOLD'
 
--- a/trade_system/risk.py
+++ b/trade_system/risk.py
@@ class RiskManager:
-    def calculate_position_size(self, price, df=None):
-        """
-        Calcula tamanho de posição baseado em volatilidade (ATR).
-        Risco fixo de 1% do capital por trade.
-        """
-        risk_per_trade = self.initial_balance * 0.01
-        if df is None or len(df) < 15:
-            return (risk_per_trade / price)
-
-        # ATR para dimensionamento dinâmico
-        atr = talib.ATR(df['high'], df['low'], df['close'], timeperiod=14)[-1]
-        return risk_per_trade / atr
+    def calculate_position_size(self, price, df=None):
+        """
+        Calcula tamanho de posição baseado em volatilidade (ATR).
+        Risco fixo de 1% do capital por trade.
+        """
+        risk_per_trade = self.initial_balance * 0.01
+        # Se não há dados suficientes, size fixo via preço
+        if df is None or len(df) < 15:
+            return risk_per_trade / price
+
+        # ATR para dimensionamento dinâmico
+        atr = talib.ATR(df['high'], df['low'], df['close'], timeperiod=14)[-1]
+        return risk_per_trade / atr
