{
  "structure": {
    "trade_system/alerts.py": {
      "imports": [
        [
          "datetime",
          "datetime, timedelta"
        ],
        [
          "typing",
          "Any, Dict, List, Optional"
        ],
        [
          "email.mime.text",
          "MIMEText"
        ],
        [
          "email.mime.multipart",
          "MIMEMultipart"
        ]
      ],
      "classes": [
        "AlertManager"
      ],
      "content": "\"\"\"Sistema de alertas multi-canal\"\"\"\nimport asyncio\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Any, Dict, List, Optional\nimport aiohttp\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nimport smtplib\n\nclass AlertManager:\n    \"\"\"Gerencia envio de alertas por m\u00faltiplos canais\"\"\"\n    \n    def __init__(self, config: Any):\n        self.config = config.alerts if hasattr(config, 'alerts') else config.get('alerts', {})\n        self.logger = logging.getLogger(__name__)\n        \n        # Rate limiting\n        self.alert_history = []\n        self.max_alerts_per_hour = 20\n        \n        # Canais\n        self.telegram_enabled = self.config.get('telegram_enabled', False)\n        self.email_enabled = self.config.get('email_enabled', False)\n        \n        self.logger.info(\"\ud83d\udce2 Sistema de alertas inicializado\")\n    \n    async def send_alert(self, message: str, alert_type: str = \"info\"):\n        \"\"\"\n        Envia alerta por todos os canais habilitados\n        \n        Args:\n            message: Mensagem do alerta\n            alert_type: Tipo do alerta (info, warning, error, trade, report)\n        \"\"\"\n        # Verificar rate limit\n        if not self._check_rate_limit():\n            self.logger.warning(\"Rate limit de alertas atingido\")\n            return\n        \n        # Formatar mensagem\n        formatted_message = self._format_message(message, alert_type)\n        \n        # Enviar por cada canal\n        tasks = []\n        \n        if self.telegram_enabled:\n            tasks.append(self._send_telegram(formatted_message, alert_type))\n        \n        if self.email_enabled:\n            tasks.append(self._send_email(formatted_message, alert_type))\n        \n        # Executar envios em paralelo\n        if tasks:\n            await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # Registrar no hist\u00f3rico\n        self.alert_history.append({\n            'timestamp': datetime.now(),\n            'type': alert_type,\n            'message': message\n        })\n    \n    async def _send_telegram(self, message: str, alert_type: str):\n        \"\"\"Envia alerta via Telegram\"\"\"\n        token = self.config.get('telegram_token', '')\n        chat_id = self.config.get('telegram_chat_id', '')\n        \n        if not token or not chat_id:\n            return\n        \n        try:\n            url = f\"https://api.telegram.org/bot{token}/sendMessage\"\n            \n            # Adicionar emoji baseado no tipo\n            emojis = {\n                'info': '\u2139\ufe0f',\n                'warning': '\u26a0\ufe0f',\n                'error': '\u274c',\n                'trade': '\ud83d\udcb0',\n                'report': '\ud83d\udcca'\n            }\n            \n            emoji = emojis.get(alert_type, '\ud83d\udccc')\n            \n            data = {\n                'chat_id': chat_id,\n                'text': f\"{emoji} {message}\",\n                'parse_mode': 'HTML',\n                'disable_web_page_preview': True\n            }\n            \n            async with aiohttp.ClientSession() as session:\n                async with session.post(url, json=data) as response:\n                    if response.status != 200:\n                        self.logger.error(f\"Erro ao enviar Telegram: {response.status}\")\n                        \n        except Exception as e:\n            self.logger.error(f\"Erro ao enviar alerta Telegram: {e}\")\n    \n    async def _send_email(self, message: str, alert_type: str):\n        \"\"\"Envia alerta via email\"\"\"\n        smtp_server = self.config.get('email_smtp', '')\n        from_email = self.config.get('email_from', '')\n        to_email = self.config.get('email_to', '')\n        \n        if not all([smtp_server, from_email, to_email]):\n            return\n        \n        try:\n            # Criar mensagem\n            msg = MIMEMultipart()\n            msg['From'] = from_email\n            msg['To'] = to_email\n            msg['Subject'] = f\"Trading Bot Alert: {alert_type.upper()}\"\n            \n            # Corpo do email\n            body = f\"\"\"\n            <html>\n                <body>\n                    <h2>Trading Bot Alert</h2>\n                    <p><strong>Type:</strong> {alert_type}</p>\n                    <p><strong>Time:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>\n                    <hr>\n                    <pre>{message}</pre>\n                </body>\n            </html>\n            \"\"\"\n            \n            msg.attach(MIMEText(body, 'html'))\n            \n            # Enviar email (simplificado - em produ\u00e7\u00e3o usar async)\n            # with smtplib.SMTP(smtp_server) as server:\n            #     server.send_message(msg)\n            \n        except Exception as e:\n            self.logger.error(f\"Erro ao enviar email: {e}\")\n    \n    def _format_message(self, message: str, alert_type: str) -> str:\n        \"\"\"Formata mensagem para envio\"\"\"\n        timestamp = datetime.now().strftime('%H:%M:%S')\n        \n        # Remover espa\u00e7os extras e formatar\n        lines = [line.strip() for line in message.strip().split('\\n')]\n        formatted = '\\n'.join(lines)\n        \n        return f\"[{timestamp}] {formatted}\"\n    \n    def _check_rate_limit(self) -> bool:\n        \"\"\"Verifica se pode enviar alerta (rate limiting)\"\"\"\n        # Limpar alertas antigos\n        one_hour_ago = datetime.now() - timedelta(hours=1)\n        self.alert_history = [\n            alert for alert in self.alert_history \n            if alert['timestamp'] > one_hour_ago\n        ]\n        \n        # Verificar limite\n        return len(self.alert_history) < self.max_alerts_per_hour\n    \n    def get_alert_stats(self) -> Dict[str, int]:\n        \"\"\"Retorna estat\u00edsticas de alertas\"\"\"\n        stats = {}\n        \n        for alert in self.alert_history:\n            alert_type = alert['type']\n            stats[alert_type] = stats.get(alert_type, 0) + 1\n        \n        return stats\n"
    },
    "trade_system/backtester.py": {
      "imports": [
        [
          "datetime",
          "datetime, timedelta"
        ],
        [
          "typing",
          "Any, Dict, List, Optional"
        ],
        [
          "trade_system.analysis.technical",
          "TechnicalAnalyzer"
        ],
        [
          "trade_system.analysis.ml",
          "MLPredictor"
        ],
        [
          "trade_system.analysis.orderbook",
          "OrderbookAnalyzer"
        ],
        [
          "trade_system.risk",
          "RiskManager"
        ],
        [
          "trade_system.signals",
          "SignalAggregator"
        ]
      ],
      "classes": [
        "Backtester"
      ],
      "content": "\"\"\"Sistema de backtesting\"\"\"\nimport pandas as pd\nimport numpy as np\nimport asyncio\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Any, Dict, List, Optional\nimport aiohttp\n\nfrom trade_system.analysis.technical import TechnicalAnalyzer\nfrom trade_system.analysis.ml import MLPredictor\nfrom trade_system.analysis.orderbook import OrderbookAnalyzer\nfrom trade_system.risk import RiskManager\nfrom trade_system.signals import SignalAggregator\n\nclass Backtester:\n    \"\"\"Sistema de backtesting para valida\u00e7\u00e3o de estrat\u00e9gias\"\"\"\n    \n    def __init__(self, config: Any):\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        \n        # Componentes\n        self.ta_analyzer = TechnicalAnalyzer(config)\n        self.ml_predictor = MLPredictor(config)\n        self.risk_manager = RiskManager(config)\n        self.signal_aggregator = SignalAggregator(config)\n        \n        # Estado\n        self.initial_balance = config.base_balance\n        self.balance = config.base_balance\n        self.trades = []\n        self.position = None\n        \n        # Dados\n        self.candles = None\n        \n    async def run(self, days: int = 30, symbol: Optional[str] = None):\n        \"\"\"\n        Executa backtest\n        \n        Args:\n            days: N\u00famero de dias para testar\n            symbol: S\u00edmbolo para testar (ou usa da config)\n        \"\"\"\n        try:\n            self.logger.info(f\"\ud83d\udd2c Executando backtest de valida\u00e7\u00e3o ({days} dias)...\")\n            \n            # Reset estado\n            self.balance = self.initial_balance\n            self.trades = []\n            self.position = None\n            \n            # Baixar dados\n            symbol = symbol or self.config.symbol\n            self.candles = await self._fetch_data(symbol, days)\n            \n            if len(self.candles) < 200:\n                self.logger.warning(\"Dados insuficientes para backtest\")\n                return\n            \n            self.logger.info(f\"\u2705 Dados carregados: {len(self.candles)} candles\")\n            self.logger.info(f\"   Per\u00edodo: {self.candles.index[0]} at\u00e9 {self.candles.index[-1]}\")\n            self.logger.info(f\"   Pre\u00e7o atual: ${self.candles['close'].iloc[-1]:,.2f}\")\n            \n            # Treinar ML com dados iniciais\n            self.logger.info(\"\ud83d\udd04 Iniciando backtest...\")\n            train_data = self.candles.iloc[:200]\n            self.ml_predictor.train(train_data, self.ta_analyzer)\n            \n            # Simular trading\n            await self._simulate_trading()\n            \n            self.logger.info(\"\u2705 Backtest conclu\u00eddo!\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erro no backtest: {e}\")\n            raise\n    \n    async def _fetch_data(self, symbol: str, days: int) -> pd.DataFrame:\n        \"\"\"Busca dados hist\u00f3ricos\"\"\"\n        self.logger.info(f\"\ud83d\udcca Baixando {days} dias de dados para {symbol}...\")\n        \n        # Calcular timestamps\n        end_time = int(datetime.now().timestamp() * 1000)\n        start_time = int((datetime.now() - timedelta(days=days)).timestamp() * 1000)\n        \n        # Binance limita a 1000 candles por request\n        limit = 1000\n        interval = '1m'  # 1 minuto\n        \n        all_candles = []\n        current_start = start_time\n        \n        async with aiohttp.ClientSession() as session:\n            while current_start < end_time:\n                url = \"https://api.binance.com/api/v3/klines\"\n                params = {\n                    'symbol': symbol,\n                    'interval': interval,\n                    'startTime': current_start,\n                    'endTime': end_time,\n                    'limit': limit\n                }\n                \n                async with session.get(url, params=params) as response:\n                    if response.status != 200:\n                        raise Exception(f\"Erro ao buscar dados: {response.status}\")\n                    \n                    data = await response.json()\n                    \n                    if not data:\n                        break\n                    \n                    all_candles.extend(data)\n                    \n                    # Pr\u00f3ximo batch\n                    last_timestamp = int(data[-1][0])\n                    current_start = last_timestamp + 1\n                    \n                    # Evitar rate limit\n                    await asyncio.sleep(0.1)\n        \n        # Converter para DataFrame\n        df = pd.DataFrame(all_candles, columns=[\n            'timestamp', 'open', 'high', 'low', 'close', 'volume',\n            'close_time', 'quote_volume', 'trades', 'buy_base_volume',\n            'buy_quote_volume', 'ignore'\n        ])\n        \n        # Converter tipos\n        for col in ['open', 'high', 'low', 'close', 'volume']:\n            df[col] = df[col].astype(float)\n        \n        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')\n        df.set_index('timestamp', inplace=True)\n        \n        # Remover duplicatas\n        df = df[~df.index.duplicated(keep='last')]\n        \n        self.logger.info(f\"\u2705 {len(df)} candles baixados\")\n        \n        return df\n    \n    async def _simulate_trading(self):\n        \"\"\"Simula trading com os dados hist\u00f3ricos\"\"\"\n        lookback = 100  # Candles necess\u00e1rios para an\u00e1lise\n        \n        for i in range(lookback, len(self.candles)):\n            # Slice de dados at\u00e9 o momento atual\n            current_candles = self.candles.iloc[:i+1]\n            current_price = current_candles['close'].iloc[-1]\n            \n            # Analisar\n            analysis_window = current_candles.iloc[-lookback:]\n            signal = await self._analyze_market(analysis_window)\n            \n            # Processar sinal\n            if signal['signal'] != 'HOLD' and not self.position:\n                # Validar trade\n                market_data = {\n                    'volatility': signal['indicators'].get('volatility', 0),\n                    'spread_bps': 10,  # Simulado\n                    'momentum': signal['indicators'].get('momentum', 0)\n                }\n                \n                can_trade, reason = self.risk_manager.validate_trade(\n                    signal['signal'], signal['confidence'], market_data\n                )\n                \n                if can_trade:\n                    self._open_position(signal['signal'], current_price, signal['confidence'])\n            \n            # Gerenciar posi\u00e7\u00e3o existente\n            elif self.position:\n                self._manage_position(current_price)\n            \n            # Atualizar ML periodicamente\n            if i % 500 == 0 and i > 200:\n                train_data = current_candles.iloc[-1000:]\n                self.ml_predictor.train(train_data, self.ta_analyzer)\n    \n    async def _analyze_market(self, candles: pd.DataFrame) -> Dict[str, Any]:\n        \"\"\"Analisa mercado no ponto atual\"\"\"\n        # An\u00e1lise t\u00e9cnica\n        ta_analysis = self.ta_analyzer.analyze(candles)\n        \n        # ML prediction\n        ml_signal = {'signal': 'HOLD', 'confidence': 0.0}\n        if ta_analysis['indicators']:\n            features = self.ml_predictor.prepare_features(candles, ta_analysis['indicators'])\n            ml_signal['signal'], ml_signal['confidence'] = self.ml_predictor.predict(features)\n        \n        # Orderbook simulado (n\u00e3o dispon\u00edvel em backtest)\n        ob_analysis = {\n            'signal': 'NEUTRAL',\n            'buy_pressure': 0.5,\n            'spread_bps': 10\n        }\n        \n        # Agregar sinais\n        return self.signal_aggregator.aggregate({\n            'technical': ta_analysis,\n            'ml': ml_signal,\n            'orderbook': ob_analysis\n        })\n    \n    def _open_position(self, signal: str, price: float, confidence: float):\n        \"\"\"Abre nova posi\u00e7\u00e3o\"\"\"\n        position_size = self.risk_manager.calculate_position_size(\n            self.balance, price, confidence\n        )\n        \n        self.position = {\n            'type': signal,\n            'entry_price': price,\n            'size': position_size,\n            'stop_loss': self.risk_manager.calculate_stop_loss(price, signal),\n            'take_profit': self.risk_manager.calculate_take_profit(price, signal, confidence),\n            'entry_time': self.candles.index[len(self.candles) - 1],\n            'confidence': confidence\n        }\n        \n        self.risk_manager.register_position(self.position)\n    \n    def _manage_position(self, current_price: float):\n        \"\"\"Gerencia posi\u00e7\u00e3o aberta\"\"\"\n        if not self.position:\n            return\n        \n        # Verificar stop loss e take profit\n        if self.position['type'] == 'BUY':\n            if current_price <= self.position['stop_loss']:\n                self._close_position(current_price, 'STOP_LOSS')\n            elif current_price >= self.position['take_profit']:\n                self._close_position(current_price, 'TAKE_PROFIT')\n            else:\n                # Trailing stop\n                new_stop = self.risk_manager.update_trailing_stop(self.position, current_price)\n                self.position['stop_loss'] = new_stop\n        else:  # SELL\n            if current_price >= self.position['stop_loss']:\n                self._close_position(current_price, 'STOP_LOSS')\n            elif current_price <= self.position['take_profit']:\n                self._close_position(current_price, 'TAKE_PROFIT')\n            else:\n                # Trailing stop\n                new_stop = self.risk_manager.update_trailing_stop(self.position, current_price)\n                self.position['stop_loss'] = new_stop\n    \n    def _close_position(self, exit_price: float, reason: str):\n        \"\"\"Fecha posi\u00e7\u00e3o\"\"\"\n        if not self.position:\n            return\n        \n        # Calcular resultado\n        if self.position['type'] == 'BUY':\n            profit_pct = (exit_price - self.position['entry_price']) / self.position['entry_price']\n        else:\n            profit_pct = (self.position['entry_price'] - exit_price) / self.position['entry_price']\n        \n        profit_usd = profit_pct * self.position['size'] * self.position['entry_price']\n        \n        # Atualizar balan\u00e7o\n        self.balance += profit_usd\n        \n        # Registrar trade\n        trade = {\n            **self.position,\n            'exit_price': exit_price,\n            'exit_time': self.candles.index[len(self.candles) - 1],\n            'exit_reason': reason,\n            'profit_pct': profit_pct,\n            'profit_usd': profit_usd\n        }\n        self.trades.append(trade)\n        \n        # Atualizar risk manager\n        self.risk_manager.close_position(self.position, exit_price, reason)\n        \n        self.position = None\n    \n    def get_metrics(self) -> Dict[str, float]:\n        \"\"\"Calcula m\u00e9tricas do backtest\"\"\"\n        if not self.trades:\n            self.logger.warning(\"\u26a0\ufe0f Nenhum trade executado no backtest\")\n            return {\n                'total_trades': 0,\n                'win_rate': 0,\n                'profit_factor': 0,\n                'sharpe_ratio': 0,\n                'max_drawdown': 0,\n                'total_return': 0\n            }\n        \n        # Trades vencedores/perdedores\n        winning_trades = [t for t in self.trades if t['profit_pct'] > 0]\n        losing_trades = [t for t in self.trades if t['profit_pct'] <= 0]\n        \n        # Win rate\n        win_rate = len(winning_trades) / len(self.trades)\n        \n        # Profit factor\n        gross_profit = sum(t['profit_usd'] for t in winning_trades) if winning_trades else 0\n        gross_loss = abs(sum(t['profit_usd'] for t in losing_trades)) if losing_trades else 1\n        profit_factor = gross_profit / gross_loss\n        \n        # Sharpe ratio\n        returns = [t['profit_pct'] for t in self.trades]\n        if len(returns) > 1:\n            sharpe_ratio = np.mean(returns) / np.std(returns) * np.sqrt(252)\n        else:\n            sharpe_ratio = 0\n        \n        # Max drawdown\n        equity_curve = [self.initial_balance]\n        for trade in self.trades:\n            equity_curve.append(equity_curve[-1] + trade['profit_usd'])\n        \n        peak = np.maximum.accumulate(equity_curve)\n        drawdown = (equity_curve - peak) / peak\n        max_drawdown = abs(np.min(drawdown))\n        \n        # Retorno total\n        total_return = (self.balance - self.initial_balance) / self.initial_balance\n        \n        return {\n            'total_trades': len(self.trades),\n            'win_rate': win_rate,\n            'profit_factor': profit_factor,\n            'sharpe_ratio': sharpe_ratio,\n            'max_drawdown': max_drawdown,\n            'total_return': total_return,\n            'final_balance': self.balance,\n            'total_profit': self.balance - self.initial_balance\n        }\n    \n    def print_results(self):\n        \"\"\"Imprime resultados do backtest\"\"\"\n        metrics = self.get_metrics()\n        \n        print(f\"\"\"\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    RESULTADOS DO BACKTEST                    \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\n\ud83d\udcca M\u00c9TRICAS DE PERFORMANCE:\n   Total de Trades: {metrics['total_trades']}\n   Taxa de Acerto: {metrics['win_rate']:.2%}\n   Profit Factor: {metrics['profit_factor']:.2f}\n   Sharpe Ratio: {metrics['sharpe_ratio']:.2f}\n   Max Drawdown: {metrics['max_drawdown']:.2%}\n\n\ud83d\udcb0 RESULTADOS FINANCEIROS:\n   Balance Inicial: ${self.initial_balance:,.2f}\n   Balance Final: ${metrics['final_balance']:,.2f}\n   Lucro/Preju\u00edzo: ${metrics['total_profit']:+,.2f}\n   Retorno Total: {metrics['total_return']:.2%}\n        \"\"\")\n        \n        if self.trades:\n            # Top trades\n            sorted_trades = sorted(self.trades, key=lambda x: x['profit_pct'], reverse=True)\n            \n            print(\"\\n\ud83d\udcc8 MELHORES TRADES:\")\n            for i, trade in enumerate(sorted_trades[:3]):\n                print(f\"   {i+1}. {trade['profit_pct']:+.2%} - {trade['exit_reason']}\")\n            \n            print(\"\\n\ud83d\udcc9 PIORES TRADES:\")\n            for i, trade in enumerate(sorted_trades[-3:]):\n                print(f\"   {i+1}. {trade['profit_pct']:+.2%} - {trade['exit_reason']}\")\n"
    },
    "trade_system/cache.py": {
      "imports": [
        [
          "datetime",
          "datetime, timedelta"
        ],
        [
          "typing",
          "Any, Dict, Optional"
        ],
        [
          "collections",
          "OrderedDict"
        ],
        [
          "typing",
          "Any, Dict, Optional"
        ]
      ],
      "classes": [
        "CacheManager"
      ],
      "content": "\"\"\"Sistema de cache com Redis e fallback local\"\"\"\nimport json\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Any, Dict, Optional\nimport redis\nfrom collections import OrderedDict\nimport pickle\nfrom typing import Any, Dict, Optional\n\nclass CacheManager:\n    \"\"\"Gerenciador de cache com Redis e fallback local\"\"\"\n    \n    def __init__(self, config: Any):\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        \n        # Configura\u00e7\u00f5es\n        self.ttl = config.system.get('cache_ttl', 60)\n        self.max_local_items = 1000\n        \n        # Tentar conectar ao Redis\n        self.redis_client = self._connect_redis()\n        \n        # Cache local (fallback)\n        self.local_cache = OrderedDict()\n        \n    def _connect_redis(self) -> Optional[redis.Redis]:\n        \"\"\"Conecta ao Redis se dispon\u00edvel\"\"\"\n        try:\n            client = redis.Redis(\n                host='localhost',\n                port=6379,\n                db=0,\n                decode_responses=False,\n                socket_connect_timeout=1\n            )\n            \n            # Testar conex\u00e3o\n            client.ping()\n            self.logger.info(\"\u2705 Redis conectado\")\n            return client\n            \n        except (redis.ConnectionError, redis.TimeoutError) as e:\n            self.logger.warning(f\"\u26a0\ufe0f Redis conex\u00e3o falhou: {e}\")\n            return None\n    \n    def get(self, key: str) -> Optional[Any]:\n        \"\"\"Recupera valor do cache\"\"\"\n        # Tentar Redis primeiro\n        if self.redis_client:\n            try:\n                value = self.redis_client.get(key)\n                if value:\n                    return pickle.loads(value)\n            except Exception as e:\n                self.logger.debug(f\"Redis get error: {e}\")\n        \n        # Fallback para cache local\n        if key in self.local_cache:\n            value, expiry = self.local_cache[key]\n            if datetime.now() < expiry:\n                # Mover para o final (LRU)\n                self.local_cache.move_to_end(key)\n                return value\n            else:\n                # Expirado\n                del self.local_cache[key]\n        \n        return None\n    \n    def set(self, key: str, value: Any, ttl: Optional[int] = None):\n        \"\"\"Armazena valor no cache\"\"\"\n        ttl = ttl or self.ttl\n        \n        # Tentar Redis\n        if self.redis_client:\n            try:\n                serialized = pickle.dumps(value)\n                self.redis_client.setex(key, ttl, serialized)\n            except Exception as e:\n                self.logger.debug(f\"Redis set error: {e}\")\n        \n        # Sempre armazenar no cache local tamb\u00e9m\n        expiry = datetime.now() + timedelta(seconds=ttl)\n        self.local_cache[key] = (value, expiry)\n        \n        # Limitar tamanho do cache local\n        if len(self.local_cache) > self.max_local_items:\n            # Remover item mais antigo\n            self.local_cache.popitem(last=False)\n    \n    def delete(self, key: str):\n        \"\"\"Remove valor do cache\"\"\"\n        # Redis\n        if self.redis_client:\n            try:\n                self.redis_client.delete(key)\n            except Exception:\n                pass\n        \n        # Local\n        if key in self.local_cache:\n            del self.local_cache[key]\n    \n    def clear(self):\n        \"\"\"Limpa todo o cache\"\"\"\n        # Redis\n        if self.redis_client:\n            try:\n                self.redis_client.flushdb()\n            except Exception:\n                pass\n        \n        # Local\n        self.local_cache.clear()\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Retorna estat\u00edsticas do cache\"\"\"\n        stats = {\n            'redis_connected': self.redis_client is not None,\n            'local_cache_size': len(self.local_cache),\n            'local_cache_items': list(self.local_cache.keys())[:10]  # Primeiros 10\n        }\n        \n        if self.redis_client:\n            try:\n                info = self.redis_client.info()\n                stats['redis_memory'] = info.get('used_memory_human', 'N/A')\n                stats['redis_keys'] = self.redis_client.dbsize()\n            except Exception:\n                pass\n        \n        return stats\n"
    },
    "trade_system/checkpoint.py": {
      "imports": [
        [
          "datetime",
          "datetime"
        ],
        [
          "pathlib",
          "Path"
        ],
        [
          "typing",
          "Any, Dict, List, Optional"
        ]
      ],
      "classes": [
        "CheckpointManager"
      ],
      "content": "\"\"\"Sistema de checkpoint e recupera\u00e7\u00e3o\"\"\"\nimport json\nimport logging\nimport asyncio\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\nimport pickle\nimport gzip\n\nclass CheckpointManager:\n    \"\"\"Gerencia checkpoints do sistema\"\"\"\n    \n    def __init__(self, config: Any):\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        \n        # Diret\u00f3rio de checkpoints\n        self.checkpoint_dir = Path(\"checkpoints\")\n        self.checkpoint_dir.mkdir(exist_ok=True)\n        \n        # Configura\u00e7\u00f5es\n        self.interval = config.system.get('checkpoint_interval', 300)\n        self.max_checkpoints = 10\n        \n    async def checkpoint_loop(self):\n        \"\"\"Loop de salvamento peri\u00f3dico\"\"\"\n        while True:\n            await asyncio.sleep(self.interval)\n            # O salvamento ser\u00e1 chamado pelo sistema principal\n    \n    async def save_checkpoint(self, data: Dict[str, Any]) -> bool:\n        \"\"\"\n        Salva checkpoint do sistema\n        \n        Args:\n            data: Dados para salvar\n            \n        Returns:\n            True se salvou com sucesso\n        \"\"\"\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = self.checkpoint_dir / f\"checkpoint_{timestamp}.json.gz\"\n            \n            # Adicionar metadados\n            checkpoint = {\n                'timestamp': datetime.now().isoformat(),\n                'version': '2.0',\n                'data': data\n            }\n            \n            # Serializar e comprimir\n            json_data = json.dumps(checkpoint, default=str)\n            compressed = gzip.compress(json_data.encode())\n            \n            # Salvar\n            with open(filename, 'wb') as f:\n                f.write(compressed)\n            \n            self.logger.info(f\"\ud83d\udcbe Checkpoint salvo: {filename}\")\n            \n            # Limpar checkpoints antigos\n            await self._cleanup_old_checkpoints()\n            \n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"Erro ao salvar checkpoint: {e}\")\n            return False\n    \n    async def load_checkpoint(self, filename: Optional[str] = None) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Carrega checkpoint\n        \n        Args:\n            filename: Nome do arquivo ou None para carregar o mais recente\n            \n        Returns:\n            Dados do checkpoint ou None\n        \"\"\"\n        try:\n            if filename:\n                filepath = self.checkpoint_dir / filename\n            else:\n                # Buscar checkpoint mais recente\n                checkpoints = sorted(self.checkpoint_dir.glob(\"checkpoint_*.json.gz\"))\n                if not checkpoints:\n                    self.logger.info(\"Nenhum checkpoint encontrado\")\n                    return None\n                filepath = checkpoints[-1]\n            \n            # Ler e descomprimir\n            with open(filepath, 'rb') as f:\n                compressed = f.read()\n            \n            json_data = gzip.decompress(compressed).decode()\n            checkpoint = json.loads(json_data)\n            \n            self.logger.info(f\"\u2705 Checkpoint carregado: {filepath}\")\n            \n            return checkpoint['data']\n            \n        except Exception as e:\n            self.logger.error(f\"Erro ao carregar checkpoint: {e}\")\n            return None\n    \n    async def _cleanup_old_checkpoints(self):\n        \"\"\"Remove checkpoints antigos\"\"\"\n        try:\n            checkpoints = sorted(self.checkpoint_dir.glob(\"checkpoint_*.json.gz\"))\n            \n            if len(checkpoints) > self.max_checkpoints:\n                for checkpoint in checkpoints[:-self.max_checkpoints]:\n                    checkpoint.unlink()\n                    self.logger.debug(f\"Checkpoint removido: {checkpoint}\")\n                    \n        except Exception as e:\n            self.logger.error(f\"Erro ao limpar checkpoints: {e}\")\n    \n    def list_checkpoints(self) -> List[Dict[str, Any]]:\n        \"\"\"Lista checkpoints dispon\u00edveis\"\"\"\n        checkpoints = []\n        \n        for filepath in sorted(self.checkpoint_dir.glob(\"checkpoint_*.json.gz\")):\n            stat = filepath.stat()\n            checkpoints.append({\n                'filename': filepath.name,\n                'size': stat.st_size,\n                'modified': datetime.fromtimestamp(stat.st_mtime),\n                'path': str(filepath)\n            })\n        \n        return checkpoints\n"
    },
    "trade_system/cli.py": {
      "imports": [
        [
          "pathlib",
          "Path"
        ],
        [
          "datetime",
          "datetime"
        ],
        [
          "trade_system.config",
          "TradingConfig"
        ],
        [
          "trade_system.logging_config",
          "setup_logging"
        ],
        [
          "trade_system.main",
          "run_paper_trading"
        ],
        [
          "trade_system.backtester",
          "Backtester"
        ],
        [
          "trade_system.backtester",
          "Backtester"
        ]
      ],
      "classes": [],
      "content": "\"\"\"Interface de linha de comando\"\"\"\nimport asyncio\nimport click\nimport sys\nfrom pathlib import Path\nfrom datetime import datetime\nimport yaml\n\nfrom trade_system.config import TradingConfig\nfrom trade_system.logging_config import setup_logging\nfrom trade_system.main import run_paper_trading\nfrom trade_system.backtester import Backtester\n\n@click.group()\n@click.version_option(version='2.0.0')\ndef cli():\n    \"\"\"Ultra Trading System - Bot de trading algor\u00edtmico de alta performance\"\"\"\n    pass\n\n@cli.command()\n@click.option('--config', '-c', type=click.Path(exists=True), \n              help='Arquivo de configura\u00e7\u00e3o')\n@click.option('--balance', '-b', type=float, \n              help='Balance inicial para paper trading')\n@click.option('--debug', is_flag=True, \n              help='Modo debug com logs detalhados')\ndef paper(config, balance, debug):\n    \"\"\"Executa o sistema em modo paper trading\"\"\"\n    print(\"\"\"\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                  PAPER TRADING MODE                          \u2551\n\u2551              Execu\u00e7\u00e3o simulada com dados reais               \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n    \"\"\")\n    \n    try:\n        asyncio.run(run_paper_trading_command(config, balance, debug))\n    except KeyboardInterrupt:\n        print(\"\\n\\n\u23f9\ufe0f Sistema interrompido pelo usu\u00e1rio\")\n        sys.exit(0)\n    except Exception as e:\n        print(f\"\\n\u274c Erro fatal: {e}\")\n        sys.exit(1)\n\n@cli.command()\n@click.option('--symbol', '-s', default='BTCUSDT', \n              help='Par de trading')\n@click.option('--days', '-d', type=int, default=7, \n              help='Dias de dados hist\u00f3ricos')\n@click.option('--config', '-c', type=click.Path(exists=True), \n              help='Arquivo de configura\u00e7\u00e3o')\ndef backtest(symbol, days, config):\n    \"\"\"Executa backtest com dados hist\u00f3ricos\"\"\"\n    print(f\"\"\"\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                      BACKTEST MODE                           \u2551\n\u2551                 Testando com {days} dias de dados                    \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n    \"\"\")\n    \n    try:\n        asyncio.run(run_backtest_command(symbol, days, config))\n    except Exception as e:\n        print(f\"\\n\u274c Erro no backtest: {e}\")\n        sys.exit(1)\n\n@cli.command()\n@click.option('--create', is_flag=True, help='Criar arquivo de configura\u00e7\u00e3o')\n@click.option('--show', is_flag=True, help='Mostrar configura\u00e7\u00e3o atual')\n@click.option('--validate', is_flag=True, help='Validar configura\u00e7\u00e3o')\ndef config(create, show, validate):\n    \"\"\"Gerencia configura\u00e7\u00f5es do sistema\"\"\"\n    if create:\n        create_config()\n    elif show:\n        show_config()\n    elif validate:\n        validate_config()\n    else:\n        click.echo(\"Use --create, --show ou --validate\")\n\nasync def run_paper_trading_command(config_file, balance, debug):\n    \"\"\"Executa paper trading com par\u00e2metros do CLI\"\"\"\n    from trade_system.backtester import Backtester\n    \n    # Configurar logging\n    log_level = \"DEBUG\" if debug else \"INFO\"\n    setup_logging(log_level)\n    \n    # Carregar configura\u00e7\u00e3o\n    if config_file:\n        config = TradingConfig.from_file(config_file)\n    else:\n        config = TradingConfig.from_env()\n    \n    # Sobrescrever balance se fornecido\n    if balance:\n        config.base_balance = balance\n    \n    # Executar backtest de valida\u00e7\u00e3o\n    print(\"\\n\ud83d\udd2c Executando backtest de valida\u00e7\u00e3o (7 dias)...\")\n    backtester = Backtester(config)\n    await backtester.run(days=7)\n    \n    metrics = backtester.get_metrics()\n    print(f\"\"\"\n\ud83d\udcca Resultados do Backtest:\n   Trades: {metrics['total_trades']}\n   Win Rate: {metrics['win_rate']:.2%}\n   Profit Factor: {metrics['profit_factor']:.2f}\n   Sharpe Ratio: {metrics['sharpe_ratio']:.2f}\n   Max Drawdown: {metrics['max_drawdown']:.2%}\n   Retorno: {metrics['total_return']:.2%}\n    \"\"\")\n    \n    # Perguntar se deseja continuar\n    if metrics['total_trades'] == 0:\n        print(\"\\n\u26a0\ufe0f Nenhum trade foi executado no backtest!\")\n        print(\"Isso pode indicar que os par\u00e2metros est\u00e3o muito restritivos.\")\n    \n    response = input(\"\\nDeseja continuar com paper trading? (s/n): \")\n    if response.lower() != 's':\n        return\n    \n    # Executar paper trading\n    await run_paper_trading(config_file, debug, balance)\n\nasync def run_backtest_command(symbol, days, config_file):\n    \"\"\"Executa backtest\"\"\"\n    # Configurar logging\n    setup_logging(\"INFO\")\n    \n    # Carregar configura\u00e7\u00e3o\n    if config_file:\n        config = TradingConfig.from_file(config_file)\n    else:\n        config = TradingConfig()\n    \n    config.symbol = symbol\n    \n    # Executar backtest\n    backtester = Backtester(config)\n    await backtester.run(days=days)\n    \n    # Mostrar resultados\n    backtester.print_results()\n\ndef create_config():\n    \"\"\"Cria arquivo de configura\u00e7\u00e3o padr\u00e3o\"\"\"\n    config = TradingConfig()\n    config.save(\"config.yaml\")\n    \n    print(\"\u2705 Arquivo config.yaml criado!\")\n    print(\"\\nPr\u00f3ximos passos:\")\n    print(\"1. Edite config.yaml com suas configura\u00e7\u00f5es\")\n    print(\"2. Configure as vari\u00e1veis de ambiente:\")\n    print(\"   export BINANCE_API_KEY='sua_chave'\")\n    print(\"   export BINANCE_API_SECRET='seu_secret'\")\n    print(\"3. Execute: trade-system paper\")\n\ndef show_config():\n    \"\"\"Mostra configura\u00e7\u00e3o atual\"\"\"\n    if Path(\"config.yaml\").exists():\n        config = TradingConfig.from_file(\"config.yaml\")\n    else:\n        config = TradingConfig.from_env()\n    \n    # Ocultar secrets\n    config_dict = config.to_dict()\n    if config_dict['api_key']:\n        config_dict['api_key'] = config_dict['api_key'][:8] + \"...\"\n    if config_dict['api_secret']:\n        config_dict['api_secret'] = config_dict['api_secret'][:8] + \"...\"\n    \n    print(\"Configura\u00e7\u00e3o atual:\")\n    print(yaml.dump(config_dict, default_flow_style=False))\n\ndef validate_config():\n    \"\"\"Valida configura\u00e7\u00e3o\"\"\"\n    if Path(\"config.yaml\").exists():\n        config = TradingConfig.from_file(\"config.yaml\")\n    else:\n        config = TradingConfig.from_env()\n    \n    issues = []\n    \n    # Verificar API keys\n    if not config.api_key or not config.api_secret:\n        issues.append(\"\u274c API Keys n\u00e3o configuradas\")\n    \n    # Verificar par\u00e2metros\n    if config.min_confidence > 0.9:\n        issues.append(\"\u26a0\ufe0f min_confidence muito alto (> 0.9)\")\n    \n    if config.max_position_pct > 0.1:\n        issues.append(\"\u26a0\ufe0f max_position_pct muito alto (> 10%)\")\n    \n    if issues:\n        print(\"Problemas encontrados:\")\n        for issue in issues:\n            print(f\"  {issue}\")\n    else:\n        print(\"\u2705 Configura\u00e7\u00e3o v\u00e1lida!\")\n\ndef main():\n    \"\"\"Fun\u00e7\u00e3o principal do CLI\"\"\"\n    cli()\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    "trade_system/config.py": {
      "imports": [
        [
          "dataclasses",
          "dataclass, field"
        ],
        [
          "typing",
          "Any, Dict, List"
        ]
      ],
      "classes": [
        "TradingConfig"
      ],
      "content": "\"\"\"Configura\u00e7\u00e3o centralizada do sistema\"\"\"\nimport os\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict, List\nimport yaml\nimport json\n\n@dataclass\nclass TradingConfig:\n    \"\"\"Configura\u00e7\u00e3o do sistema de trading\"\"\"\n    # API\n    api_key: str = \"\"\n    api_secret: str = \"\"\n    testnet: bool = False\n    \n    # Trading\n    symbol: str = \"BTCUSDT\"\n    base_balance: float = 10000.0\n    min_confidence: float = 0.75\n    max_position_pct: float = 0.02\n    min_order_size: float = 10.0\n    \n    # Risk Management\n    risk: Dict[str, Any] = field(default_factory=lambda: {\n        'max_volatility': 0.05,\n        'max_spread_bps': 20,\n        'max_daily_loss': 0.02,\n        'stop_loss_pct': 0.015,\n        'take_profit_pct': 0.03,\n        'trailing_stop_pct': 0.01,\n        'max_positions': 1,\n        'position_timeout_hours': 24\n    })\n    \n    # Technical Analysis\n    ta: Dict[str, Any] = field(default_factory=lambda: {\n        'rsi_period': 14,\n        'rsi_buy_threshold': 30,\n        'rsi_sell_threshold': 70,\n        'macd_fast': 12,\n        'macd_slow': 26,\n        'macd_signal': 9,\n        'bb_period': 20,\n        'bb_std': 2.0,\n        'ema_short': 9,\n        'ema_long': 21,\n        'atr_period': 14,\n        'momentum_period': 10\n    })\n    \n    # Machine Learning\n    ml: Dict[str, Any] = field(default_factory=lambda: {\n        'features': [\n            'rsi', 'macd', 'macd_signal', 'bb_upper', 'bb_lower', \n            'bb_middle', 'volume_ratio', 'price_change', 'volatility',\n            'momentum', 'support', 'resistance', 'trend_strength',\n            'volume_profile', 'ema_diff', 'atr'\n        ],\n        'lookback': 100,\n        'retrain_interval': 1000,\n        'model_type': 'gradient_boosting',\n        'test_size': 0.2,\n        'n_estimators': 100\n    })\n    \n    # WebSocket\n    websocket: Dict[str, Any] = field(default_factory=lambda: {\n        'buffer_size': 1000,\n        'reconnect_delay': 5,\n        'ping_interval': 30,\n        'streams': ['trade', 'depth20@100ms', 'kline_1m']\n    })\n    \n    # System\n    system: Dict[str, Any] = field(default_factory=lambda: {\n        'log_level': 'INFO',\n        'checkpoint_interval': 300,\n        'health_check_interval': 60,\n        'cache_ttl': 60,\n        'rate_limit_per_minute': 1200\n    })\n    \n    # Alerts\n    alerts: Dict[str, Any] = field(default_factory=lambda: {\n        'telegram_enabled': True,\n        'telegram_token': '',\n        'telegram_chat_id': '',\n        'email_enabled': False,\n        'email_smtp': '',\n        'email_from': '',\n        'email_to': ''\n    })\n    \n    @classmethod\n    def from_file(cls, filepath: str = \"config.yaml\") -> 'TradingConfig':\n        \"\"\"Carrega configura\u00e7\u00e3o de arquivo\"\"\"\n        if os.path.exists(filepath):\n            with open(filepath, 'r') as f:\n                data = yaml.safe_load(f)\n                return cls(**data) if data else cls()\n        return cls()\n    \n    @classmethod\n    def from_env(cls) -> 'TradingConfig':\n        \"\"\"Carrega configura\u00e7\u00e3o de vari\u00e1veis de ambiente\"\"\"\n        config = cls()\n        config.api_key = os.getenv('BINANCE_API_KEY', '')\n        config.api_secret = os.getenv('BINANCE_API_SECRET', '')\n        config.alerts['telegram_token'] = os.getenv('TELEGRAM_BOT_TOKEN', '')\n        config.alerts['telegram_chat_id'] = os.getenv('TELEGRAM_CHAT_ID', '')\n        return config\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Converte para dicion\u00e1rio\"\"\"\n        return {\n            'api_key': self.api_key,\n            'api_secret': self.api_secret,\n            'testnet': self.testnet,\n            'symbol': self.symbol,\n            'base_balance': self.base_balance,\n            'min_confidence': self.min_confidence,\n            'max_position_pct': self.max_position_pct,\n            'min_order_size': self.min_order_size,\n            'risk': self.risk,\n            'ta': self.ta,\n            'ml': self.ml,\n            'websocket': self.websocket,\n            'system': self.system,\n            'alerts': self.alerts\n        }\n    \n    def save(self, filepath: str = \"config.yaml\"):\n        \"\"\"Salva configura\u00e7\u00e3o em arquivo\"\"\"\n        with open(filepath, 'w') as f:\n            yaml.dump(self.to_dict(), f, default_flow_style=False)\n"
    },
    "trade_system/learning.py": {
      "imports": [
        [
          "datetime",
          "datetime, timedelta"
        ],
        [
          "typing",
          "Dict, List, Tuple"
        ]
      ],
      "classes": [
        "TradeLearning"
      ],
      "content": "#!/usr/bin/env python3\n\"\"\"\nM\u00f3dulo de aprendizado - Analisa trades e melhora estrat\u00e9gias\n\"\"\"\n\nimport json\nimport os\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Tuple\nimport numpy as np\n\nclass TradeLearning:\n    \"\"\"Sistema de aprendizado com trades\"\"\"\n    \n    def __init__(self):\n        self.trades_file = \"data/trades_history.json\"\n        self.patterns_file = \"data/winning_patterns.json\"\n        self.ensure_data_dir()\n        self.load_data()\n    \n    def ensure_data_dir(self):\n        \"\"\"Garante que o diret\u00f3rio de dados existe\"\"\"\n        os.makedirs(\"data\", exist_ok=True)\n    \n    def load_data(self):\n        \"\"\"Carrega hist\u00f3rico de trades\"\"\"\n        if os.path.exists(self.trades_file):\n            with open(self.trades_file, 'r') as f:\n                self.trades = json.load(f)\n        else:\n            self.trades = []\n        \n        if os.path.exists(self.patterns_file):\n            with open(self.patterns_file, 'r') as f:\n                self.patterns = json.load(f)\n        else:\n            self.patterns = {}\n    \n    def save_data(self):\n        \"\"\"Salva dados\"\"\"\n        with open(self.trades_file, 'w') as f:\n            json.dump(self.trades, f, indent=2)\n        \n        with open(self.patterns_file, 'w') as f:\n            json.dump(self.patterns, f, indent=2)\n    \n    def record_trade(self, trade_data: Dict):\n        \"\"\"Registra um trade para an\u00e1lise\"\"\"\n        trade_data['timestamp'] = datetime.now().isoformat()\n        self.trades.append(trade_data)\n        self.save_data()\n        \n        # Analisar padr\u00f5es\n        self.analyze_patterns()\n    \n    def analyze_patterns(self):\n        \"\"\"Analisa padr\u00f5es vencedores e perdedores\"\"\"\n        if len(self.trades) < 10:\n            return\n        \n        winning_trades = [t for t in self.trades if t['profit_loss'] > 0]\n        losing_trades = [t for t in self.trades if t['profit_loss'] < 0]\n        \n        # Padr\u00f5es de trades vencedores\n        if winning_trades:\n            self.patterns['winning'] = {\n                'avg_rsi': np.mean([t['indicators']['rsi'] for t in winning_trades]),\n                'avg_volume_ratio': np.mean([t['indicators']['volume_ratio'] for t in winning_trades]),\n                'avg_confidence': np.mean([t['confidence'] for t in winning_trades]),\n                'common_action': max(set([t['action'] for t in winning_trades]), \n                                   key=[t['action'] for t in winning_trades].count),\n                'best_hours': self.get_best_trading_hours(winning_trades)\n            }\n        \n        # Padr\u00f5es de trades perdedores\n        if losing_trades:\n            self.patterns['losing'] = {\n                'avg_rsi': np.mean([t['indicators']['rsi'] for t in losing_trades]),\n                'avg_volume_ratio': np.mean([t['indicators']['volume_ratio'] for t in losing_trades]),\n                'avg_confidence': np.mean([t['confidence'] for t in losing_trades]),\n                'common_action': max(set([t['action'] for t in losing_trades]), \n                                   key=[t['action'] for t in losing_trades].count),\n                'worst_hours': self.get_best_trading_hours(losing_trades)\n            }\n        \n        self.save_data()\n    \n    def get_best_trading_hours(self, trades: List[Dict]) -> List[int]:\n        \"\"\"Identifica melhores hor\u00e1rios para trading\"\"\"\n        hours = [datetime.fromisoformat(t['timestamp']).hour for t in trades]\n        hour_counts = {}\n        for h in hours:\n            hour_counts[h] = hour_counts.get(h, 0) + 1\n        \n        # Top 3 hor\u00e1rios\n        sorted_hours = sorted(hour_counts.items(), key=lambda x: x[1], reverse=True)\n        return [h[0] for h in sorted_hours[:3]]\n    \n    def get_recommendations(self, current_indicators: Dict) -> Dict:\n        \"\"\"Gera recomenda\u00e7\u00f5es baseadas no aprendizado\"\"\"\n        if 'winning' not in self.patterns:\n            return {'action': 'WAIT', 'reason': 'Dados insuficientes para an\u00e1lise'}\n        \n        winning = self.patterns['winning']\n        current_hour = datetime.now().hour\n        \n        # Verificar se \u00e9 um bom hor\u00e1rio\n        good_hour = current_hour in winning.get('best_hours', [])\n        \n        # Comparar indicadores\n        rsi_match = abs(current_indicators.get('rsi', 50) - winning['avg_rsi']) < 10\n        volume_match = current_indicators.get('volume_ratio', 1) > winning['avg_volume_ratio'] * 0.8\n        \n        if good_hour and rsi_match and volume_match:\n            return {\n                'action': winning['common_action'],\n                'confidence_boost': 0.1,\n                'reason': f\"Padr\u00e3o vencedor detectado (RSI: {winning['avg_rsi']:.1f}, Volume: {winning['avg_volume_ratio']:.2f})\"\n            }\n        \n        return {'action': 'WAIT', 'reason': 'Condi\u00e7\u00f5es n\u00e3o correspondem a padr\u00f5es vencedores'}\n    \n    def get_stats(self) -> Dict:\n        \"\"\"Retorna estat\u00edsticas gerais\"\"\"\n        if not self.trades:\n            return {}\n        \n        total_trades = len(self.trades)\n        winning_trades = len([t for t in self.trades if t['profit_loss'] > 0])\n        total_profit = sum(t['profit_loss'] for t in self.trades)\n        \n        return {\n            'total_trades': total_trades,\n            'winning_trades': winning_trades,\n            'win_rate': (winning_trades / total_trades * 100) if total_trades > 0 else 0,\n            'total_profit': total_profit,\n            'avg_profit_per_trade': total_profit / total_trades if total_trades > 0 else 0,\n            'best_trade': max(self.trades, key=lambda t: t['profit_loss'])['profit_loss'] if self.trades else 0,\n            'worst_trade': min(self.trades, key=lambda t: t['profit_loss'])['profit_loss'] if self.trades else 0\n        }\n\n# Inst\u00e2ncia global\nlearning_system = TradeLearning()\n"
    },
    "trade_system/logging_config.py": {
      "imports": [
        [
          "datetime",
          "datetime"
        ],
        [
          "pathlib",
          "Path"
        ]
      ],
      "classes": [],
      "content": "\"\"\"Configura\u00e7\u00e3o de logging centralizada\"\"\"\nimport logging\nimport sys\nfrom datetime import datetime\nfrom pathlib import Path\nimport colorlog\n\ndef setup_logging(level: str = \"INFO\", log_dir: str = \"logs\"):\n    \"\"\"Configura sistema de logging com cores e arquivo\"\"\"\n    # Criar diret\u00f3rio de logs\n    Path(log_dir).mkdir(exist_ok=True)\n    \n    # Nome do arquivo de log\n    log_file = Path(log_dir) / f\"trading_{datetime.now().strftime('%Y%m%d')}.log\"\n    \n    # Formato para arquivo\n    file_formatter = logging.Formatter(\n        '%(asctime)s.%(msecs)03d [%(levelname)s] %(name)s: %(message)s',\n        datefmt='%H:%M:%S'\n    )\n    \n    # Formato colorido para console\n    console_formatter = colorlog.ColoredFormatter(\n        '%(asctime)s.%(msecs)03d %(log_color)s[%(levelname)s]%(reset)s %(blue)s%(name)s%(reset)s: %(message)s',\n        datefmt='%H:%M:%S',\n        log_colors={\n            'DEBUG': 'cyan',\n            'INFO': 'green',\n            'WARNING': 'yellow',\n            'ERROR': 'red',\n            'CRITICAL': 'red,bg_white',\n        }\n    )\n    \n    # Handler para arquivo\n    file_handler = logging.FileHandler(log_file, encoding='utf-8')\n    file_handler.setFormatter(file_formatter)\n    \n    # Handler para console\n    console_handler = logging.StreamHandler(sys.stdout)\n    console_handler.setFormatter(console_formatter)\n    \n    # Configurar logger raiz\n    root_logger = logging.getLogger()\n    root_logger.setLevel(getattr(logging, level.upper()))\n    root_logger.addHandler(file_handler)\n    root_logger.addHandler(console_handler)\n    \n    # Suprimir logs excessivos de bibliotecas\n    logging.getLogger('urllib3').setLevel(logging.WARNING)\n    logging.getLogger('websockets').setLevel(logging.WARNING)\n    \n    logger = logging.getLogger(__name__)\n    logger.info(f\"Sistema de logging configurado - N\u00edvel: {level}\")\n    logger.info(f\"Logs salvos em: {log_file}\")\n    \n    return logger\n"
    },
    "trade_system/main.py": {
      "imports": [
        [
          "datetime",
          "datetime"
        ],
        [
          "typing",
          "Dict, List, Optional, Tuple"
        ],
        [
          "trade_system.config",
          "TradingConfig"
        ],
        [
          "trade_system.logging_config",
          "setup_logging"
        ],
        [
          "trade_system.cache",
          "CacheManager"
        ],
        [
          "trade_system.rate_limiter",
          "RateLimiter"
        ],
        [
          "trade_system.alerts",
          "AlertManager"
        ],
        [
          "trade_system.websocket_manager",
          "WebSocketManager"
        ],
        [
          "trade_system.analysis.technical",
          "TechnicalAnalyzer"
        ],
        [
          "trade_system.analysis.orderbook",
          "OrderbookAnalyzer"
        ],
        [
          "trade_system.analysis.ml",
          "SimplifiedMLPredictor"
        ],
        [
          "trade_system.risk",
          "RiskManager"
        ],
        [
          "trade_system.validation",
          "MarketConditionValidator"
        ],
        [
          "trade_system.signals",
          "OptimizedSignalConsolidator"
        ],
        [
          "trade_system.checkpoint",
          "CheckpointManager"
        ],
        [
          "trade_system.risk",
          "Position"
        ]
      ],
      "classes": [
        "TradingSystem"
      ],
      "content": "\"\"\"\nM\u00f3dulo principal para orquestra\u00e7\u00e3o do sistema de trading\nVers\u00e3o aprimorada com gest\u00e3o de risco avan\u00e7ada\n\"\"\"\nimport os\nimport time\nimport asyncio\nimport signal\nfrom datetime import datetime\nimport numpy as np\nfrom typing import Dict, List, Optional, Tuple\nimport logging\n\nfrom trade_system.config import TradingConfig\nfrom trade_system.logging_config import setup_logging\nfrom trade_system.cache import CacheManager\nfrom trade_system.rate_limiter import RateLimiter\nfrom trade_system.alerts import AlertManager\nfrom trade_system.websocket_manager import WebSocketManager\nfrom trade_system.analysis.technical import TechnicalAnalyzer\nfrom trade_system.analysis.orderbook import OrderbookAnalyzer\nfrom trade_system.analysis.ml import SimplifiedMLPredictor\nfrom trade_system.risk import RiskManager\nfrom trade_system.validation import MarketConditionValidator\nfrom trade_system.signals import OptimizedSignalConsolidator\nfrom trade_system.checkpoint import CheckpointManager\n\nlogger = logging.getLogger(__name__)\n\n\nclass TradingSystem:\n    \"\"\"Sistema principal de trading com prote\u00e7\u00f5es aprimoradas\"\"\"\n\n    def __init__(self, config=None, paper_trading: bool = True):\n        self.config = config or TradingConfig.from_env()\n        self.paper_trading = paper_trading\n\n        # Infraestrutura\n        self.cache = CacheManager(self.config)\n        self.rate_limiter = RateLimiter(self.config)\n        self.alert_system = AlertManager(self.config)\n        self.ws_manager = WebSocketManager(self.config, self.cache)\n\n        # M\u00f3dulos de an\u00e1lise\n        self.technical_analyzer = UltraFastTechnicalAnalysis(self.config)\n        self.orderbook_analyzer = OrderbookAnalyzer(self.config)\n        self.ml_predictor = SimplifiedWebSocketManager()\n        self.signal_consolidator = OptimizedSignalConsolidator()\n\n        # Gest\u00e3o de risco e valida\u00e7\u00e3o de mercado\n        self.risk_manager = RiskManager(self.config)\n        self.market_validator = MarketConditionValidator(self.config)\n\n        # Gerenciamento de checkpoint\n        self.checkpoint_manager = CheckpointManager()\n\n        # Estado interno\n        self.position: Optional[Dict] = None\n        self.is_running = False\n        self.last_price = None\n        self.last_signal_time = 0\n        self.signal_cooldown = self.config.get('signal_cooldown', 60)  # 60s entre trades\n        \n        self.performance_stats: Dict[str, float] = {\n            'total_trades': 0,\n            'winning_trades': 0,\n            'total_pnl': 0.0,\n            'total_fees': 0.0,\n            'start_balance': self.risk_manager.current_balance,\n            'session_start': datetime.now().timestamp()\n        }\n\n        logger.info(f\"\ud83d\ude80 Sistema inicializado - Modo: {'PAPER TRADING' if paper_trading else 'LIVE'}\")\n\n    async def initialize(self):\n        \"\"\"Inicializa componentes ass\u00edncronos e carrega checkpoint\"\"\"\n        checkpoint = self.checkpoint_manager.load_latest_checkpoint()\n        if checkpoint:\n            self._restore_from_checkpoint(checkpoint)\n\n        self.ws_manager.start_delayed()\n        await self.alert_system.send_startup_alert(\"PAPER\" if self.paper_trading else \"LIVE\")\n\n        logger.info(\"\u23f3 Aguardando dados do WebSocket...\")\n        for _ in range(50):\n            await asyncio.sleep(0.1)\n            if self.ws_manager.buffer_filled or self.ws_manager.buffer_index > 100:\n                logger.info(\"\u2705 Dados recebidos!\")\n                break\n\n    async def run(self):\n        \"\"\"Loop principal de coleta, an\u00e1lise e execu\u00e7\u00e3o com prote\u00e7\u00f5es aprimoradas\"\"\"\n        self.is_running = True\n        cycle = 0\n        interval_s = self.config.main_loop_interval_ms / 1000.0\n        log_every = max(1, int(10 / interval_s))  # a cada ~10s\n\n        try:\n            while self.is_running:\n                data = self.ws_manager.get_latest_data()\n                if not data:\n                    await asyncio.sleep(0.1)\n                    continue\n\n                # Atualiza \u00faltimo pre\u00e7o\n                self.last_price = float(data['prices'][-1])\n\n                # 1) Verificar stop loss/take profit se tem posi\u00e7\u00e3o aberta\n                if hasattr(self.risk_manager, 'has_open_position') and self.risk_manager.has_open_position():\n                    await self._check_positions_exit()\n\n                # 2) Validar condi\u00e7\u00f5es de mercado\n                is_safe, reasons = await self.market_validator.validate(data)\n                if not is_safe and not self.config.debug_mode:\n                    if cycle % log_every == 0:\n                        logger.warning(f\"\u26a0\ufe0f Mercado inseguro: {', '.join(reasons)}\")\n                    await asyncio.sleep(0.1)\n                    cycle += 1\n                    continue\n\n                # 3) Gerar sinais\n                signals = await self._analyze_market(data)\n                action, confidence = self.signal_consolidator.consolidate(signals)\n\n                # 4) Gerenciar posi\u00e7\u00f5es com prote\u00e7\u00f5es\n                if self.position or (hasattr(self.risk_manager, 'has_open_position') and self.risk_manager.has_open_position()):\n                    await self._manage_position(data, action, confidence)\n                else:\n                    # Verificar cooldown entre trades\n                    if action != 'HOLD' and confidence >= self.config.min_confidence:\n                        current_time = time.time()\n                        if current_time - self.last_signal_time >= self.signal_cooldown:\n                            await self._open_position(data, action, confidence)\n                            self.last_signal_time = current_time\n                        else:\n                            remaining = self.signal_cooldown - (current_time - self.last_signal_time)\n                            if cycle % log_every == 0:\n                                logger.debug(f\"\u23f3 Cooldown ativo: {remaining:.0f}s restantes\")\n\n                # 5) Checkpoint peri\u00f3dico\n                if self.checkpoint_manager.should_checkpoint():\n                    await self._save_checkpoint()\n\n                cycle += 1\n                await asyncio.sleep(interval_s)\n\n        except Exception as e:\n            logger.error(f\"\u274c Erro no loop principal: {e}\", exc_info=True)\n            await self.alert_system.send_alert(\"Erro no Sistema\", str(e), \"critical\")\n        finally:\n            await self.shutdown()\n\n    async def _check_positions_exit(self):\n        \"\"\"Verifica condi\u00e7\u00f5es de sa\u00edda das posi\u00e7\u00f5es abertas\"\"\"\n        position = self.risk_manager.get_open_position()\n        if not position or not self.last_price:\n            return\n        \n        exit_reason = self.risk_manager.check_exit_conditions(position, self.last_price)\n        \n        if exit_reason:\n            result = self.risk_manager.close_position(position, self.last_price, exit_reason)\n            \n            # Atualiza estat\u00edsticas\n            self.performance_stats['total_trades'] += 1\n            if result['pnl'] > 0:\n                self.performance_stats['winning_trades'] += 1\n            self.performance_stats['total_pnl'] += result['pnl']\n            \n            logger.info(f\"\ud83d\udcca Trade fechado por {exit_reason}\")\n            logger.info(f\"   P&L: ${result['pnl']:.2f} ({result['pnl_pct']:.2f}%)\")\n            logger.info(f\"   Novo balan\u00e7o: ${result['new_balance']:.2f}\")\n            \n            # Limpa posi\u00e7\u00e3o local\n            self.position = None\n            \n            # Salva checkpoint\n            await self._save_checkpoint()\n            \n            # Alerta\n            await self.alert_system.send_alert(\n                f\"Posi\u00e7\u00e3o Fechada - {exit_reason}\",\n                f\"P&L: ${result['pnl']:.2f}\\nBalan\u00e7o: ${result['new_balance']:.2f}\",\n                \"info\"\n            )\n\n    async def _analyze_market(self, market_data: Dict) -> List[Tuple[str, str, float]]:\n        \"\"\"Executa as tr\u00eas camadas de an\u00e1lise e retorna a lista de sinais\"\"\"\n        # T\u00e9cnica\n        tech_act, tech_conf, tech_det = self.technical_analyzer.analyze(\n            market_data['prices'], market_data['volumes']\n        )\n        # Orderbook\n        ob_act, ob_conf, ob_det = self.orderbook_analyzer.analyze(\n            market_data['orderbook_bids'],\n            market_data['orderbook_asks'],\n            self.cache\n        )\n        # ML\n        features = {\n            'rsi': tech_det.get('rsi', 50.0),\n            'momentum': self._calculate_momentum(market_data['prices']),\n            'volume_ratio': self._calculate_volume_ratio(market_data['volumes']),\n            'spread_bps': ob_det.get('spread_bps', 0.0),\n            'volatility': self._calculate_volatility(market_data['prices']),\n        }\n        ml_act, ml_conf = self.ml_predictor.predict(features)\n\n        return [\n            ('technical', tech_act, tech_conf),\n            ('orderbook', ob_act, ob_conf),\n            ('ml', ml_act, ml_conf),\n        ]\n\n    async def _open_position(self, data: Dict, action: str, confidence: float):\n        \"\"\"Dispara abertura de posi\u00e7\u00e3o com verifica\u00e7\u00f5es aprimoradas\"\"\"\n        # Verifica\u00e7\u00e3o adicional de posi\u00e7\u00e3o aberta\n        if hasattr(self.risk_manager, 'has_open_position') and self.risk_manager.has_open_position():\n            logger.warning(\"\u26a0\ufe0f Tentativa de abrir posi\u00e7\u00e3o com posi\u00e7\u00e3o j\u00e1 aberta\")\n            return\n            \n        if self.paper_trading:\n            await self._open_paper_position(data, action, confidence)\n        else:\n            logger.error(\"\u26a0\ufe0f Trading real ainda n\u00e3o implementado\")\n\n    async def _open_paper_position(self, data: Dict, action: str, confidence: float):\n        \"\"\"Abre posi\u00e7\u00e3o simulada com prote\u00e7\u00f5es aprimoradas\"\"\"\n        price = float(data['prices'][-1])\n        vol = self._calculate_volatility(data['prices'])\n        \n        # Usa novo m\u00e9todo se dispon\u00edvel\n        if hasattr(self.risk_manager, 'calculate_position_size'):\n            position_info = self.risk_manager.calculate_position_size(price, confidence, vol)\n            value = position_info['size']\n            qty = position_info['quantity']\n        else:\n            value = self.risk_manager.calculate_position_size(confidence, vol, price)\n            qty = value / price\n            \n        if value <= 0:\n            return\n\n        fee = value * self.config.fee_rate  # ex: 0.001\n        \n        # Cria posi\u00e7\u00e3o com novo sistema se dispon\u00edvel\n        if hasattr(self.risk_manager, 'open_position'):\n            position = self.risk_manager.open_position(\n                side=action,\n                price=price,\n                quantity=qty,\n                size=value,\n                current_time=time.time()\n            )\n            \n            if not position:\n                logger.warning(\"\u26a0\ufe0f N\u00e3o foi poss\u00edvel abrir posi\u00e7\u00e3o\")\n                return\n                \n            self.position = {\n                'side': action,\n                'entry_price': price,\n                'quantity': qty,\n                'entry_time': time.time(),\n                'confidence': confidence,\n                'entry_fee': fee,\n                'paper_trade': True,\n                'stop_loss': position.stop_loss,\n                'take_profit': position.take_profit\n            }\n        else:\n            # Fallback para sistema antigo\n            self.position = {\n                'side': action,\n                'entry_price': price,\n                'quantity': qty,\n                'entry_time': time.time(),\n                'confidence': confidence,\n                'entry_fee': fee,\n                'paper_trade': True,\n            }\n            self.risk_manager.set_position(self.position)\n            \n        self.risk_manager.current_balance -= fee\n\n        logger.info(f\"\ud83d\udfe2 POSI\u00c7\u00c3O ABERTA [{action}] price=${price:.2f} size=${value:.2f} qty={qty:.6f} fee=${fee:.2f}\")\n        \n        # Log stop loss e take profit se dispon\u00edvel\n        if hasattr(self.position, 'stop_loss') or 'stop_loss' in self.position:\n            sl = self.position.get('stop_loss', 0)\n            tp = self.position.get('take_profit', 0)\n            if sl and tp:\n                logger.info(f\"   Stop Loss: ${sl:.2f} | Take Profit: ${tp:.2f}\")\n        \n        await self.alert_system.send_alert(\n            f\"Nova Posi\u00e7\u00e3o {action}\",\n            f\"Pre\u00e7o: ${price:.2f}\\nValor: ${value:.2f}\\nConf: {confidence:.1%}\",\n            \"info\"\n        )\n\n    async def _manage_position(self, data: Dict, action: str, confidence: float):\n        \"\"\"Verifica se deve fechar a posi\u00e7\u00e3o atual com l\u00f3gica aprimorada\"\"\"\n        price = float(data['prices'][-1])\n        \n        # Se tem o novo sistema, verifica primeiro\n        if hasattr(self.risk_manager, 'has_open_position') and self.risk_manager.has_open_position():\n            position = self.risk_manager.get_open_position()\n            \n            # S\u00f3 processa sinal contr\u00e1rio\n            if (position.side == 'BUY' and action == 'SELL' and confidence >= self.config.min_confidence) or \\\n               (position.side == 'SELL' and action == 'BUY' and confidence >= self.config.min_confidence):\n                # Fecha por revers\u00e3o de sinal\n                result = self.risk_manager.close_position(position, price, 'SIGNAL_REVERSAL')\n                \n                # Atualiza estat\u00edsticas\n                self.performance_stats['total_trades'] += 1\n                if result['pnl'] > 0:\n                    self.performance_stats['winning_trades'] += 1\n                self.performance_stats['total_pnl'] += result['pnl']\n                \n                logger.info(f\"\ud83d\udd04 Fechando posi\u00e7\u00e3o por revers\u00e3o de sinal\")\n                self.position = None\n                \n                # Espera um pouco antes de abrir nova posi\u00e7\u00e3o\n                await asyncio.sleep(2)\n                \n                # Pode abrir nova posi\u00e7\u00e3o se configurado\n                if self.config.get('allow_reversal_trades', True):\n                    await self._open_position(data, action, confidence)\n            else:\n                # Ignora sinal na mesma dire\u00e7\u00e3o\n                if action != 'HOLD':\n                    logger.debug(f\"\u23ed\ufe0f Ignorando sinal {action} - posi\u00e7\u00e3o {position.side} aberta\")\n        \n        elif self.position:\n            # Fallback para sistema antigo\n            should_close, reason = self.risk_manager.should_close_position(\n                price,\n                self.position['entry_price'],\n                self.position['side']\n            )\n            if should_close:\n                await self._close_position(price, reason)\n\n    async def _close_position(self, exit_price: float, reason: str):\n        \"\"\"Fecha posi\u00e7\u00e3o simulada, atualiza P&L e risk metrics\"\"\"\n        if not self.position:\n            return\n            \n        entry_price = self.position['entry_price']\n        qty = self.position['quantity']\n        side = self.position['side']\n\n        pnl = (exit_price - entry_price) * qty if side == 'BUY' else (entry_price - exit_price) * qty\n        exit_fee = exit_price * qty * self.config.fee_rate\n        pnl_net = pnl - exit_fee\n        total_fees = self.position['entry_fee'] + exit_fee\n\n        # Estat\u00edsticas\n        self.performance_stats['total_trades'] += 1\n        if pnl_net > 0:\n            self.performance_stats['winning_trades'] += 1\n        self.performance_stats['total_pnl'] += pnl_net\n        self.performance_stats['total_fees'] += total_fees\n\n        # Atualiza risk manager\n        self.risk_manager.update_after_trade(pnl_net, exit_fee)\n        self.risk_manager.clear_position()\n        self.position = None\n\n        logger.info(f\"\ud83d\udd34 POSI\u00c7\u00c3O FECHADA exit=${exit_price:.2f} P&L=${pnl_net:.2f} fees=${total_fees:.2f} reason={reason}\")\n        \n        # Calcula win rate\n        win_rate = (self.performance_stats['winning_trades'] / self.performance_stats['total_trades'] * 100) if self.performance_stats['total_trades'] > 0 else 0\n        logger.info(f\"   Win Rate: {win_rate:.1f}% | Total P&L: ${self.performance_stats['total_pnl']:.2f}\")\n        \n        await self.alert_system.send_alert(\n            \"Posi\u00e7\u00e3o Fechada\",\n            f\"P&L: ${pnl_net:.2f}\\nFees: ${total_fees:.2f}\\nMotivo: {reason}\\nWin Rate: {win_rate:.1f}%\",\n            \"info\"\n        )\n\n    async def _save_checkpoint(self):\n        \"\"\"Salva checkpoint com informa\u00e7\u00f5es adicionais\"\"\"\n        state = {\n            'balance': self.risk_manager.current_balance,\n            'position': self.position,\n            'performance_stats': self.performance_stats,\n            'paper_trading': self.paper_trading,\n            'last_signal_time': self.last_signal_time,\n            # Adiciona estat\u00edsticas do risk manager se dispon\u00edvel\n            'risk_stats': {\n                'daily_pnl': getattr(self.risk_manager, 'daily_pnl', 0),\n                'total_trades': getattr(self.risk_manager, 'total_trades', 0),\n                'winning_trades': getattr(self.risk_manager, 'winning_trades', 0),\n                'losing_trades': getattr(self.risk_manager, 'losing_trades', 0)\n            } if hasattr(self.risk_manager, 'daily_pnl') else {}\n        }\n        self.checkpoint_manager.save_checkpoint(state)\n        self.checkpoint_manager.update_checkpoint_time()\n        logger.debug(\"\u2705 Checkpoint salvo\")\n\n    def _restore_from_checkpoint(self, ckpt: Dict):\n        \"\"\"Restaura estado do checkpoint com informa\u00e7\u00f5es adicionais\"\"\"\n        self.risk_manager.current_balance = ckpt.get('balance', self.risk_manager.initial_balance)\n        self.position = ckpt.get('position')\n        self.performance_stats = ckpt.get('performance_stats', self.performance_stats)\n        self.last_signal_time = ckpt.get('last_signal_time', 0)\n        \n        # Restaura estat\u00edsticas do risk manager se dispon\u00edvel\n        risk_stats = ckpt.get('risk_stats', {})\n        if risk_stats and hasattr(self.risk_manager, 'daily_pnl'):\n            self.risk_manager.daily_pnl = risk_stats.get('daily_pnl', 0)\n            self.risk_manager.total_trades = risk_stats.get('total_trades', 0)\n            self.risk_manager.winning_trades = risk_stats.get('winning_trades', 0)\n            self.risk_manager.losing_trades = risk_stats.get('losing_trades', 0)\n        \n        # Restaura posi\u00e7\u00e3o no risk manager se dispon\u00edvel\n        if self.position and hasattr(self.risk_manager, 'positions'):\n            # Recria objeto Position se necess\u00e1rio\n            from trade_system.risk import Position\n            pos = Position(\n                side=self.position['side'],\n                entry_price=self.position['entry_price'],\n                quantity=self.position['quantity'],\n                size=self.position.get('size', self.position['quantity'] * self.position['entry_price']),\n                entry_time=self.position.get('entry_time', time.time()),\n                stop_loss=self.position.get('stop_loss'),\n                take_profit=self.position.get('take_profit')\n            )\n            self.risk_manager.positions = [pos]\n        \n        logger.info(\"\u2705 Estado restaurado do checkpoint\")\n        logger.info(f\"   Balan\u00e7o: ${self.risk_manager.current_balance:.2f}\")\n        logger.info(f\"   Trades: {self.performance_stats['total_trades']}\")\n        if self.position:\n            logger.info(f\"   Posi\u00e7\u00e3o aberta: {self.position['side']} @ ${self.position['entry_price']:.2f}\")\n\n    async def shutdown(self):\n        \"\"\"Encerra sistema com seguran\u00e7a aprimorada\"\"\"\n        logger.info(\"\ud83d\uded1 Desligando sistema...\")\n        self.is_running = False\n        \n        # Fecha posi\u00e7\u00f5es abertas se configurado\n        if self.config.get('close_on_shutdown', False) and self.last_price:\n            if hasattr(self.risk_manager, 'has_open_position') and self.risk_manager.has_open_position():\n                position = self.risk_manager.get_open_position()\n                result = self.risk_manager.close_position(position, self.last_price, 'SYSTEM_SHUTDOWN')\n                logger.info(f\"\ud83d\udcca Posi\u00e7\u00e3o fechada no desligamento - P&L: ${result['pnl']:.2f}\")\n            elif self.position:\n                await self._close_position(self.last_price, 'SYSTEM_SHUTDOWN')\n        \n        self.ws_manager.stop()\n        await self._save_checkpoint()\n        \n        # Log estat\u00edsticas finais\n        total_return = ((self.risk_manager.current_balance - self.performance_stats['start_balance']) / \n                       self.performance_stats['start_balance'] * 100)\n        win_rate = (self.performance_stats['winning_trades'] / self.performance_stats['total_trades'] * 100) if self.performance_stats['total_trades'] > 0 else 0\n        \n        logger.info(\"\ud83d\udcca Estat\u00edsticas da Sess\u00e3o:\")\n        logger.info(f\"   Total de trades: {self.performance_stats['total_trades']}\")\n        logger.info(f\"   Win rate: {win_rate:.1f}%\")\n        logger.info(f\"   P&L total: ${self.performance_stats['total_pnl']:.2f}\")\n        logger.info(f\"   Fees totais: ${self.performance_stats['total_fees']:.2f}\")\n        logger.info(f\"   Retorno: {total_return:.2f}%\")\n        logger.info(f\"   Balan\u00e7o final: ${self.risk_manager.current_balance:.2f}\")\n        \n        await self.alert_system.send_shutdown_alert()\n        logger.info(\"\u2705 Sistema desligado\")\n\n    # M\u00e9todos utilit\u00e1rios de c\u00e1lculo de features\n    def _calculate_momentum(self, prices: List[float]) -> float:\n        if len(prices) < 20:\n            return 0.0\n        return (prices[-1] - prices[-20]) / prices[-20]\n\n    def _calculate_volume_ratio(self, volumes: List[float]) -> float:\n        if len(volumes) < 20:\n            return 1.0\n        avg = np.mean(volumes[-20:])\n        return float(volumes[-1] / avg) if avg > 0 else 1.0\n\n    def _calculate_volatility(self, prices: List[float]) -> float:\n        if len(prices) < 50:\n            return 0.01\n        arr = np.array(prices[-50:], dtype=np.float64)\n        return float(np.std(arr) / np.mean(arr))\n\n\nasync def run_paper_trading(\n    config=None,\n    initial_balance: float = 10000.0,\n    debug_mode: bool = False\n):\n    \"\"\"Ponto de entrada para paper trading com configura\u00e7\u00f5es aprimoradas\"\"\"\n    setup_logging()\n    cfg = config or TradingConfig.from_env(debug_mode=debug_mode)\n    cfg.debug_mode = debug_mode\n\n    # Adiciona configura\u00e7\u00f5es de prote\u00e7\u00e3o se n\u00e3o existirem\n    if not hasattr(cfg, 'signal_cooldown'):\n        cfg.signal_cooldown = 60  # 60s entre trades\n    if not hasattr(cfg, 'allow_reversal_trades'):\n        cfg.allow_reversal_trades = True\n    if not hasattr(cfg, 'close_on_shutdown'):\n        cfg.close_on_shutdown = False\n\n    system = TradingSystem(cfg, paper_trading=True)\n    # ajusta balance inicial\n    system.risk_manager.current_balance = initial_balance\n    system.risk_manager.initial_balance = initial_balance\n\n    await system.initialize()\n    try:\n        await system.run()\n    except KeyboardInterrupt:\n        logger.info(\"\u23f9\ufe0f Interrompido pelo usu\u00e1rio\")\n        await system.shutdown()\n\n\ndef handle_signals():\n    \"\"\"Configura tratamento de SIGINT/SIGTERM\"\"\"\n    def _handler(sig, frame):\n        logger.info(f\"Sinal {sig} recebido, encerrando...\")\n    signal.signal(signal.SIGINT, _handler)\n    signal.signal(signal.SIGTERM, _handler)\n\n\nif __name__ == \"__main__\":\n    handle_signals()\n    asyncio.run(run_paper_trading(debug_mode=True))\n"
    },
    "trade_system/paper_trader.py": {
      "imports": [
        [
          "datetime",
          "datetime"
        ],
        [
          "dataclasses",
          "dataclass, field"
        ],
        [
          "typing",
          "Any, Dict, Generator, List"
        ]
      ],
      "classes": [
        "PaperTrader"
      ],
      "content": "# -*- coding: utf-8 -*-\n\"\"\"M\u00f3dulo de paper trading simples\"\"\"\nimport json\nfrom datetime import datetime\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict, Generator, List\nimport logging\nimport random\nimport requests\n\nlogger = logging.getLogger(__name__)\n\n\ndef fetch_market_price(symbol: str) -> float:\n    \"\"\"Obt\u00e9m pre\u00e7o atual do s\u00edmbolo usando API p\u00fablica da Binance\"\"\"\n    url = \"https://api.binance.com/api/v3/ticker/price\"\n    try:\n        resp = requests.get(url, params={\"symbol\": symbol}, timeout=5)\n        resp.raise_for_status()\n        return float(resp.json()[\"price\"])\n    except Exception as exc:\n        logger.warning(f\"Falha ao obter pre\u00e7o de {symbol}: {exc}\")\n        return 0.0\n\n\n@dataclass\nclass PaperTrader:\n    capital_inicial: float\n    capital: float = field(init=False)\n    posicoes: Dict[str, float] = field(default_factory=dict)\n    historico: List[Dict[str, Any]] = field(default_factory=list)\n\n    def __post_init__(self):\n        self.capital = self.capital_inicial\n        logger.info(f\"PaperTrader iniciado com capital inicial de ${self.capital_inicial:,.2f}\")\n\n    def obter_preco(self, symbol: str) -> float:\n        return fetch_market_price(symbol)\n\n    def comprar(self, symbol: str, quantidade: float):\n        preco = self.obter_preco(symbol)\n        custo = preco * quantidade\n        if custo > self.capital:\n            raise ValueError(\"Capital insuficiente para comprar\")\n        self.capital -= custo\n        self.posicoes[symbol] = self.posicoes.get(symbol, 0.0) + quantidade\n        self.historico.append({\n            \"tipo\": \"BUY\", \"symbol\": symbol, \"qtd\": quantidade,\n            \"preco\": preco, \"timestamp\": datetime.utcnow().isoformat()\n        })\n        logger.info(f\"BUY {quantidade} {symbol} @ ${preco:,.2f} (capital: ${self.capital:,.2f})\")\n\n    def vender(self, symbol: str, quantidade: float):\n        if self.posicoes.get(symbol, 0.0) < quantidade:\n            raise ValueError(\"Posi\u00e7\u00e3o insuficiente para vender\")\n        preco = self.obter_preco(symbol)\n        self.capital += preco * quantidade\n        self.posicoes[symbol] -= quantidade\n        self.historico.append({\n            \"tipo\": \"SELL\", \"symbol\": symbol, \"qtd\": quantidade,\n            \"preco\": preco, \"timestamp\": datetime.utcnow().isoformat()\n        })\n        logger.info(f\"SELL {quantidade} {symbol} @ ${preco:,.2f} (capital: ${self.capital:,.2f})\")\n\n    def resumo(self) -> Dict[str, Any]:\n        valor_posicoes = sum(self.obter_preco(s) * q for s, q in self.posicoes.items())\n        lucro = self.capital + valor_posicoes - self.capital_inicial\n        return {\n            \"capital_restante\": self.capital,\n            \"posicoes\": {s: q for s, q in self.posicoes.items() if q},\n            \"lucro_prejuizo\": lucro,\n            \"operacoes\": len(self.historico)\n        }\n\n    def salvar_historico(self, caminho: str):\n        with open(caminho, \"w\", encoding=\"utf-8\") as f:\n            json.dump(self.historico, f, ensure_ascii=False, indent=2)\n        logger.info(f\"Hist\u00f3rico salvo em {caminho}\")\n\n\ndef gerar_sinais_simulados(\n    n: int = 5, symbol: str = \"BTCUSDT\", quantidade: float = 0.001\n) -> Generator[Dict[str, Any], None, None]:\n    \"\"\"Gera sinais de compra/venda aleat\u00f3rios para demonstra\u00e7\u00e3o\"\"\"\n    for _ in range(n):\n        yield {\n            \"tipo\": random.choice([\"BUY\", \"SELL\"]),\n            \"symbol\": symbol,\n            \"quantidade\": quantidade,\n        }\n"
    },
    "trade_system/rate_limiter.py": {
      "imports": [
        [
          "collections",
          "deque"
        ],
        [
          "typing",
          "Any, Dict, Optional"
        ]
      ],
      "classes": [
        "RateLimiter"
      ],
      "content": "\"\"\"Sistema de rate limiting\"\"\"\nimport time\nimport logging\nfrom collections import deque\nfrom typing import Any, Dict, Optional\nimport asyncio\n\nclass RateLimiter:\n    \"\"\"Controla rate limits de API\"\"\"\n    \n    def __init__(self, config: Any):\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        \n        # Limite padr\u00e3o da Binance: 1200 requests por minuto\n        self.max_requests_per_minute = config.system.get('rate_limit_per_minute', 1200)\n        \n        # Fila de timestamps de requests\n        self.request_times = deque()\n        \n        # Lock para thread safety\n        self.lock = asyncio.Lock()\n        \n    async def acquire(self, weight: int = 1) -> bool:\n        \"\"\"\n        Adquire permiss\u00e3o para fazer request\n        \n        Args:\n            weight: Peso do request (alguns endpoints custam mais)\n            \n        Returns:\n            True se pode fazer request\n        \"\"\"\n        async with self.lock:\n            now = time.time()\n            \n            # Limpar requests antigos (mais de 1 minuto)\n            while self.request_times and self.request_times[0] < now - 60:\n                self.request_times.popleft()\n            \n            # Verificar se pode fazer request\n            current_weight = len(self.request_times)\n            \n            if current_weight + weight > self.max_requests_per_minute:\n                # Calcular tempo de espera\n                oldest_request = self.request_times[0]\n                wait_time = 60 - (now - oldest_request) + 0.1\n                \n                self.logger.warning(f\"Rate limit atingido. Aguardando {wait_time:.1f}s\")\n                await asyncio.sleep(wait_time)\n                \n                # Tentar novamente\n                return await self.acquire(weight)\n            \n            # Registrar request\n            for _ in range(weight):\n                self.request_times.append(now)\n            \n            return True\n    \n    def get_current_usage(self) -> Dict[str, int]:\n        \"\"\"Retorna uso atual do rate limit\"\"\"\n        now = time.time()\n        \n        # Contar requests no \u00faltimo minuto\n        recent_requests = sum(1 for t in self.request_times if t > now - 60)\n        \n        return {\n            'current': recent_requests,\n            'limit': self.max_requests_per_minute,\n            'percentage': (recent_requests / self.max_requests_per_minute) * 100\n        }\n"
    },
    "trade_system/risk.py": {
      "imports": [
        [
          "datetime",
          "datetime, timedelta"
        ],
        [
          "typing",
          "Any, Dict, Optional, Tuple"
        ]
      ],
      "classes": [
        "RiskManager"
      ],
      "content": "\"\"\"Sistema de gest\u00e3o de risco\"\"\"\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Any, Dict, Optional, Tuple\nimport numpy as np\n\nclass RiskManager:\n    \"\"\"Gerenciador de risco avan\u00e7ado\"\"\"\n    \n    def __init__(self, config: Any):\n        \"\"\"\n        Inicializa o gerenciador de risco\n        \n        Args:\n            config: Objeto TradingConfig ou dicion\u00e1rio de configura\u00e7\u00e3o\n        \"\"\"\n        self.logger = logging.getLogger(__name__)\n        \n        # Extrair configura\u00e7\u00f5es de risco\n        if hasattr(config, 'risk'):\n            self.config = config.risk\n        elif isinstance(config, dict) and 'risk' in config:\n            self.config = config['risk']\n        elif isinstance(config, dict):\n            self.config = config\n        else:\n            # Configura\u00e7\u00f5es padr\u00e3o se nada for fornecido\n            self.config = {\n                'max_volatility': 0.05,\n                'max_spread_bps': 20,\n                'max_daily_loss': 0.02,\n                'stop_loss_pct': 0.015,\n                'take_profit_pct': 0.03,\n                'trailing_stop_pct': 0.01,\n                'max_positions': 1,\n                'position_timeout_hours': 24\n            }\n            self.logger.warning(\"Usando configura\u00e7\u00f5es de risco padr\u00e3o\")\n        \n        # Estado\n        self.daily_stats = {\n            'loss': 0.0,\n            'trades': 0,\n            'winning_trades': 0,\n            'losing_trades': 0,\n            'last_reset': datetime.now().date()\n        }\n        \n        self.position_history = []\n        self.current_positions = []\n        \n        self.logger.info(\"\ud83d\udee1\ufe0f Risk Manager inicializado\")\n        \n    def validate_trade(self, signal: str, confidence: float, \n                      market_data: Dict[str, float]) -> Tuple[bool, str]:\n        \"\"\"\n        Valida se um trade pode ser executado\n        \n        Args:\n            signal: BUY, SELL ou HOLD\n            confidence: Confian\u00e7a do sinal (0-1)\n            market_data: Dados de mercado incluindo volatilidade e spread\n            \n        Returns:\n            Tuple (pode_executar, motivo)\n        \"\"\"\n        # Reset di\u00e1rio se necess\u00e1rio\n        self._check_daily_reset()\n        \n        # Verifica\u00e7\u00f5es de valida\u00e7\u00e3o\n        checks = [\n            self._check_confidence(confidence),\n            self._check_daily_loss(),\n            self._check_volatility(market_data.get('volatility', 0)),\n            self._check_spread(market_data.get('spread_bps', 0)),\n            self._check_position_limit(),\n            self._check_market_hours(),\n            self._check_momentum(market_data.get('momentum', 0))\n        ]\n        \n        # Executar todas as verifica\u00e7\u00f5es\n        for is_valid, reason in checks:\n            if not is_valid:\n                self.logger.warning(f\"\u274c Trade rejeitado: {reason}\")\n                return False, reason\n        \n        self.logger.info(f\"\u2705 Trade validado: {signal} com confian\u00e7a {confidence:.2%}\")\n        return True, \"Trade aprovado\"\n    \n    def _check_confidence(self, confidence: float) -> Tuple[bool, str]:\n        \"\"\"Verifica confian\u00e7a m\u00ednima\"\"\"\n        min_confidence = self.config.get('min_confidence', 0.75)\n        if confidence < min_confidence:\n            return False, f\"Confian\u00e7a baixa: {confidence:.2%} < {min_confidence:.2%}\"\n        return True, \"\"\n    \n    def _check_daily_loss(self) -> Tuple[bool, str]:\n        \"\"\"Verifica limite de perda di\u00e1ria\"\"\"\n        max_daily_loss = self.config.get('max_daily_loss', 0.02)\n        if abs(self.daily_stats['loss']) >= max_daily_loss:\n            return False, f\"Limite de perda di\u00e1ria atingido: {self.daily_stats['loss']:.2%}\"\n        return True, \"\"\n    \n    def _check_volatility(self, volatility: float) -> Tuple[bool, str]:\n        \"\"\"Verifica volatilidade do mercado\"\"\"\n        max_volatility = self.config.get('max_volatility', 0.05)\n        if volatility > max_volatility:\n            return False, f\"Volatilidade muito alta: {volatility:.2%} > {max_volatility:.2%}\"\n        return True, \"\"\n    \n    def _check_spread(self, spread_bps: float) -> Tuple[bool, str]:\n        \"\"\"Verifica spread bid-ask\"\"\"\n        max_spread = self.config.get('max_spread_bps', 20)\n        if spread_bps > max_spread:\n            return False, f\"Spread muito alto: {spread_bps:.1f} bps > {max_spread} bps\"\n        return True, \"\"\n    \n    def _check_position_limit(self) -> Tuple[bool, str]:\n        \"\"\"Verifica limite de posi\u00e7\u00f5es abertas\"\"\"\n        max_positions = self.config.get('max_positions', 1)\n        if len(self.current_positions) >= max_positions:\n            return False, f\"Limite de posi\u00e7\u00f5es atingido: {len(self.current_positions)}/{max_positions}\"\n        return True, \"\"\n    \n    def _check_market_hours(self) -> Tuple[bool, str]:\n        \"\"\"Verifica hor\u00e1rio de trading\"\"\"\n        current_hour = datetime.now().hour\n        # Evitar hor\u00e1rios de baixa liquidez (2-6 UTC)\n        if 2 <= current_hour <= 6:\n            return False, \"Hor\u00e1rio de baixa liquidez (2-6 UTC)\"\n        return True, \"\"\n    \n    def _check_momentum(self, momentum: float) -> Tuple[bool, str]:\n        \"\"\"Verifica momentum do mercado\"\"\"\n        # Se momentum muito negativo, evitar compras\n        if momentum < -5:\n            return False, f\"Momentum muito negativo: {momentum:.2f}\"\n        return True, \"\"\n    \n    def calculate_position_size(self, balance: float, price: float, \n                              confidence: float = 0.75) -> float:\n        \"\"\"\n        Calcula tamanho da posi\u00e7\u00e3o usando Kelly Criterion modificado\n        \n        Args:\n            balance: Saldo dispon\u00edvel\n            price: Pre\u00e7o atual do ativo\n            confidence: Confian\u00e7a do sinal\n            \n        Returns:\n            Tamanho da posi\u00e7\u00e3o em unidades do ativo\n        \"\"\"\n        # Kelly Criterion: f = (p*b - q) / b\n        # p = probabilidade de ganho, q = probabilidade de perda, b = odds\n        \n        win_rate = self._calculate_win_rate()\n        avg_win = self._calculate_avg_win()\n        avg_loss = self._calculate_avg_loss()\n        \n        if avg_loss == 0:\n            odds = 2.0  # Default\n        else:\n            odds = avg_win / abs(avg_loss)\n        \n        # Kelly fraction\n        kelly = (win_rate * odds - (1 - win_rate)) / odds\n        \n        # Aplicar fator de seguran\u00e7a (25% do Kelly)\n        kelly_safe = kelly * 0.25\n        \n        # Ajustar por confian\u00e7a\n        kelly_adjusted = kelly_safe * confidence\n        \n        # Limitar ao m\u00e1ximo configurado\n        max_position_pct = self.config.get('max_position_pct', 0.02)\n        position_pct = min(kelly_adjusted, max_position_pct)\n        \n        # Garantir posi\u00e7\u00e3o m\u00ednima\n        position_size = max(position_pct * balance / price, 10 / price)\n        \n        self.logger.info(f\"\ud83d\udcca Position size: {position_size:.8f} ({position_pct:.2%} do balance)\")\n        \n        return position_size\n    \n    def calculate_stop_loss(self, entry_price: float, signal: str, \n                          volatility: float = 0.01) -> float:\n        \"\"\"Calcula stop loss din\u00e2mico baseado em volatilidade\"\"\"\n        base_stop = self.config.get('stop_loss_pct', 0.015)\n        \n        # Ajustar stop por volatilidade\n        volatility_multiplier = max(1, volatility / 0.01)\n        adjusted_stop = base_stop * volatility_multiplier\n        \n        if signal == 'BUY':\n            return entry_price * (1 - adjusted_stop)\n        else:  # SELL\n            return entry_price * (1 + adjusted_stop)\n    \n    def calculate_take_profit(self, entry_price: float, signal: str,\n                            confidence: float = 0.75) -> float:\n        \"\"\"Calcula take profit baseado em confian\u00e7a\"\"\"\n        base_tp = self.config.get('take_profit_pct', 0.03)\n        \n        # Ajustar TP por confian\u00e7a\n        confidence_multiplier = 0.5 + confidence  # 0.5x a 1.5x\n        adjusted_tp = base_tp * confidence_multiplier\n        \n        if signal == 'BUY':\n            return entry_price * (1 + adjusted_tp)\n        else:  # SELL\n            return entry_price * (1 - adjusted_tp)\n    \n    def update_trailing_stop(self, position: Dict, current_price: float) -> float:\n        \"\"\"Atualiza trailing stop de uma posi\u00e7\u00e3o\"\"\"\n        trailing_pct = self.config.get('trailing_stop_pct', 0.01)\n        \n        if position['type'] == 'BUY':\n            new_stop = current_price * (1 - trailing_pct)\n            if new_stop > position['stop_loss']:\n                self.logger.info(f\"\ud83d\udcc8 Trailing stop atualizado: ${new_stop:.2f}\")\n                return new_stop\n        else:  # SELL\n            new_stop = current_price * (1 + trailing_pct)\n            if new_stop < position['stop_loss']:\n                self.logger.info(f\"\ud83d\udcc9 Trailing stop atualizado: ${new_stop:.2f}\")\n                return new_stop\n        \n        return position['stop_loss']\n    \n    def register_position(self, position: Dict):\n        \"\"\"Registra nova posi\u00e7\u00e3o\"\"\"\n        position['open_time'] = datetime.now()\n        position['timeout_time'] = datetime.now() + timedelta(\n            hours=self.config.get('position_timeout_hours', 24)\n        )\n        self.current_positions.append(position)\n        self.daily_stats['trades'] += 1\n    \n    def close_position(self, position: Dict, exit_price: float, reason: str):\n        \"\"\"Fecha posi\u00e7\u00e3o e atualiza estat\u00edsticas\"\"\"\n        # Calcular resultado\n        if position['type'] == 'BUY':\n            profit_pct = (exit_price - position['entry_price']) / position['entry_price']\n        else:  # SELL\n            profit_pct = (position['entry_price'] - exit_price) / position['entry_price']\n        \n        # Atualizar estat\u00edsticas\n        self.daily_stats['loss'] -= profit_pct  # Negativo se for lucro\n        \n        if profit_pct > 0:\n            self.daily_stats['winning_trades'] += 1\n        else:\n            self.daily_stats['losing_trades'] += 1\n        \n        # Registrar no hist\u00f3rico\n        position['exit_price'] = exit_price\n        position['exit_time'] = datetime.now()\n        position['profit_pct'] = profit_pct\n        position['exit_reason'] = reason\n        self.position_history.append(position)\n        \n        # Remover das posi\u00e7\u00f5es abertas\n        self.current_positions = [p for p in self.current_positions \n                                 if p != position]\n        \n        self.logger.info(f\"\ud83d\udcb0 Posi\u00e7\u00e3o fechada: {profit_pct:+.2%} ({reason})\")\n    \n    def check_position_timeout(self, position: Dict) -> bool:\n        \"\"\"Verifica se posi\u00e7\u00e3o expirou\"\"\"\n        return datetime.now() > position.get('timeout_time', datetime.max)\n    \n    def _calculate_win_rate(self) -> float:\n        \"\"\"Calcula taxa de acerto hist\u00f3rica\"\"\"\n        if not self.position_history:\n            return 0.5  # Default\n        \n        winning = sum(1 for p in self.position_history if p['profit_pct'] > 0)\n        return winning / len(self.position_history)\n    \n    def _calculate_avg_win(self) -> float:\n        \"\"\"Calcula ganho m\u00e9dio\"\"\"\n        wins = [p['profit_pct'] for p in self.position_history if p['profit_pct'] > 0]\n        return np.mean(wins) if wins else 0.02  # Default 2%\n    \n    def _calculate_avg_loss(self) -> float:\n        \"\"\"Calcula perda m\u00e9dia\"\"\"\n        losses = [p['profit_pct'] for p in self.position_history if p['profit_pct'] <= 0]\n        return np.mean(losses) if losses else -0.01  # Default -1%\n    \n    def _check_daily_reset(self):\n        \"\"\"Reseta estat\u00edsticas di\u00e1rias se necess\u00e1rio\"\"\"\n        if datetime.now().date() > self.daily_stats['last_reset']:\n            self.daily_stats = {\n                'loss': 0.0,\n                'trades': 0,\n                'winning_trades': 0,\n                'losing_trades': 0,\n                'last_reset': datetime.now().date()\n            }\n            self.logger.info(\"\ud83d\udcca Estat\u00edsticas di\u00e1rias resetadas\")\n    \n    def get_risk_metrics(self) -> Dict[str, Any]:\n        \"\"\"Retorna m\u00e9tricas de risco atuais\"\"\"\n        return {\n            'daily_loss': self.daily_stats['loss'],\n            'daily_trades': self.daily_stats['trades'],\n            'win_rate': self._calculate_win_rate(),\n            'avg_win': self._calculate_avg_win(),\n            'avg_loss': self._calculate_avg_loss(),\n            'open_positions': len(self.current_positions),\n            'total_trades': len(self.position_history)\n        }\n"
    },
    "trade_system/signals.py": {
      "imports": [
        [
          "typing",
          "Any, Dict, List, Tuple"
        ]
      ],
      "classes": [
        "SignalAggregator"
      ],
      "content": "\"\"\"Agregador de sinais de m\u00faltiplas fontes\"\"\"\nimport logging\nfrom typing import Any, Dict, List, Tuple\nimport numpy as np\n\nclass SignalAggregator:\n    \"\"\"Agrega e pondera sinais de diferentes an\u00e1lises\"\"\"\n    \n    def __init__(self, config: Any):\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        \n        # Pesos padr\u00e3o para cada fonte\n        self.weights = {\n            'technical': 0.40,\n            'ml': 0.35,\n            'orderbook': 0.25\n        }\n        \n        # Hist\u00f3rico de sinais\n        self.signal_history = []\n        \n    def aggregate(self, signals: Dict[str, Dict]) -> Dict[str, Any]:\n        \"\"\"\n        Agrega sinais de m\u00faltiplas fontes\n        \n        Args:\n            signals: Dict com sinais de cada fonte\n            \n        Returns:\n            Sinal agregado final\n        \"\"\"\n        try:\n            # Coletar sinais v\u00e1lidos\n            valid_signals = self._collect_valid_signals(signals)\n            \n            if not valid_signals:\n                return self._empty_signal()\n            \n            # Calcular pontua\u00e7\u00f5es\n            buy_score, sell_score = self._calculate_scores(valid_signals)\n            \n            # Determinar sinal final\n            signal, confidence = self._determine_final_signal(buy_score, sell_score)\n            \n            # Compilar resultado\n            result = {\n                'signal': signal,\n                'confidence': confidence,\n                'buy_score': buy_score,\n                'sell_score': sell_score,\n                'sources': valid_signals,\n                'indicators': self._merge_indicators(signals)\n            }\n            \n            # Adicionar ao hist\u00f3rico\n            self.signal_history.append(result)\n            if len(self.signal_history) > 100:\n                self.signal_history.pop(0)\n            \n            return result\n            \n        except Exception as e:\n            self.logger.error(f\"Erro ao agregar sinais: {e}\")\n            return self._empty_signal()\n    \n    def _collect_valid_signals(self, signals: Dict[str, Dict]) -> List[Tuple[str, str, float, float]]:\n        \"\"\"Coleta sinais v\u00e1lidos com suas fontes\"\"\"\n        valid_signals = []\n        \n        for source, data in signals.items():\n            if not isinstance(data, dict):\n                continue\n                \n            signal = data.get('signal', 'HOLD')\n            confidence = data.get('confidence', 0.0)\n            \n            # Validar sinal\n            if signal in ['BUY', 'SELL', 'STRONG_BUY', 'STRONG_SELL'] and confidence > 0:\n                weight = self.weights.get(source, 0.0)\n                valid_signals.append((source, signal, confidence, weight))\n        \n        return valid_signals\n    \n    def _calculate_scores(self, valid_signals: List[Tuple]) -> Tuple[float, float]:\n        \"\"\"Calcula pontua\u00e7\u00f5es de compra e venda\"\"\"\n        buy_score = 0.0\n        sell_score = 0.0\n        \n        for source, signal, confidence, weight in valid_signals:\n            weighted_score = confidence * weight\n            \n            if signal in ['BUY', 'STRONG_BUY']:\n                multiplier = 1.5 if signal == 'STRONG_BUY' else 1.0\n                buy_score += weighted_score * multiplier\n            elif signal in ['SELL', 'STRONG_SELL']:\n                multiplier = 1.5 if signal == 'STRONG_SELL' else 1.0\n                sell_score += weighted_score * multiplier\n        \n        # Normalizar pontua\u00e7\u00f5es\n        total_weight = sum(self.weights.values())\n        buy_score = buy_score / total_weight\n        sell_score = sell_score / total_weight\n        \n        return buy_score, sell_score\n    \n    def _determine_final_signal(self, buy_score: float, sell_score: float) -> Tuple[str, float]:\n        \"\"\"Determina sinal final baseado nas pontua\u00e7\u00f5es\"\"\"\n        # Threshold m\u00ednimo\n        min_threshold = 0.5\n        \n        if buy_score > sell_score and buy_score > min_threshold:\n            confidence = buy_score\n            signal = 'BUY'\n        elif sell_score > buy_score and sell_score > min_threshold:\n            confidence = sell_score\n            signal = 'SELL'\n        else:\n            confidence = max(buy_score, sell_score)\n            signal = 'HOLD'\n        \n        return signal, confidence\n    \n    def _merge_indicators(self, signals: Dict[str, Dict]) -> Dict[str, Any]:\n        \"\"\"Mescla indicadores de todas as fontes\"\"\"\n        indicators = {}\n        \n        # Technical indicators\n        if 'technical' in signals and 'indicators' in signals['technical']:\n            indicators.update(signals['technical']['indicators'])\n        \n        # Orderbook metrics\n        if 'orderbook' in signals:\n            ob_data = signals['orderbook']\n            for key in ['spread_bps', 'imbalance', 'buy_pressure', 'volatility']:\n                if key in ob_data:\n                    indicators[key] = ob_data[key]\n        \n        return indicators\n    \n    def _empty_signal(self) -> Dict[str, Any]:\n        \"\"\"Retorna sinal vazio\"\"\"\n        return {\n            'signal': 'HOLD',\n            'confidence': 0.0,\n            'buy_score': 0.0,\n            'sell_score': 0.0,\n            'sources': [],\n            'indicators': {}\n        }\n    \n    def get_signal_consistency(self) -> float:\n        \"\"\"Calcula consist\u00eancia dos sinais recentes\"\"\"\n        if len(self.signal_history) < 10:\n            return 0.5\n        \n        recent_signals = [s['signal'] for s in self.signal_history[-10:]]\n        \n        # Contar sinais\n        buy_count = sum(1 for s in recent_signals if s == 'BUY')\n        sell_count = sum(1 for s in recent_signals if s == 'SELL')\n        hold_count = sum(1 for s in recent_signals if s == 'HOLD')\n        \n        # Consist\u00eancia \u00e9 alta quando um tipo domina\n        max_count = max(buy_count, sell_count, hold_count)\n        consistency = max_count / len(recent_signals)\n        \n        return consistency\n    \n    def update_weights(self, performance_metrics: Dict[str, float]):\n        \"\"\"Atualiza pesos baseado em performance\"\"\"\n        # TODO: Implementar ajuste adaptativo de pesos\n        pass\n"
    },
    "trade_system/trade_logger.py": {
      "imports": [
        [
          "datetime",
          "datetime"
        ],
        [
          "typing",
          "Dict"
        ]
      ],
      "classes": [
        "TradeLogger"
      ],
      "content": "#!/usr/bin/env python3\n\"\"\"\nLogger simples para registrar trades e enviar notifica\u00e7\u00f5es\n\"\"\"\n\nimport json\nimport os\nfrom datetime import datetime\nfrom typing import Dict\n\nclass TradeLogger:\n    \"\"\"Registra todos os trades para an\u00e1lise\"\"\"\n    \n    def __init__(self, alerts_manager=None):\n        self.trades_file = \"logs/trades_paper.json\"\n        self.alerts = alerts_manager\n        self.ensure_log_dir()\n        self.load_trades()\n    \n    def ensure_log_dir(self):\n        \"\"\"Garante que o diret\u00f3rio existe\"\"\"\n        os.makedirs(os.path.dirname(self.trades_file), exist_ok=True)\n    \n    def load_trades(self):\n        \"\"\"Carrega hist\u00f3rico de trades\"\"\"\n        if os.path.exists(self.trades_file):\n            with open(self.trades_file, 'r') as f:\n                self.trades = json.load(f)\n        else:\n            self.trades = []\n    \n    def save_trades(self):\n        \"\"\"Salva trades\"\"\"\n        with open(self.trades_file, 'w') as f:\n            json.dump(self.trades, f, indent=2)\n    \n    def log_trade(self, trade_data: Dict):\n        \"\"\"Registra um trade e notifica via Telegram\"\"\"\n        trade_data['timestamp'] = datetime.now().isoformat()\n        self.trades.append(trade_data)\n        self.save_trades()\n        \n        # Notificar via Telegram\n        if self.alerts and 'exit_price' in trade_data:\n            self.notify_closed_trade(trade_data)\n    \n    def notify_closed_trade(self, trade: Dict):\n        \"\"\"Notifica trade fechado via Telegram\"\"\"\n        profit_loss = trade.get('profit_loss', 0)\n        emoji = \"\u2705\" if profit_loss > 0 else \"\u274c\"\n        \n        message = f\"\"\"\n{emoji} **Trade Fechado**\n\nTipo: {trade.get('type', 'N/A')}\nEntrada: ${trade.get('entry_price', 0):,.2f}\nSa\u00edda: ${trade.get('exit_price', 0):,.2f}\nResultado: ${profit_loss:,.2f}\nSaldo: ${trade.get('balance', 0):,.2f}\n\n#PaperTrading\n\"\"\"\n        \n        if self.alerts:\n            self.alerts.send_trade_alert(\n                action=trade.get('type', 'TRADE'),\n                price=trade.get('exit_price', 0),\n                confidence=trade.get('confidence', 0),\n                reason=f\"P/L: ${profit_loss:,.2f}\"\n            )\n\n# Inst\u00e2ncia global\ntrade_logger = None\n\ndef init_trade_logger(alerts_manager=None):\n    \"\"\"Inicializa o logger\"\"\"\n    global trade_logger\n    trade_logger = TradeLogger(alerts_manager)\n    return trade_logger\n"
    },
    "trade_system/utils.py": {
      "imports": [
        [
          "typing",
          "Any, Dict, List, Optional"
        ],
        [
          "datetime",
          "datetime, timedelta"
        ],
        [
          "trade_system.logging_config",
          "logging.getLogger"
        ]
      ],
      "classes": [],
      "content": "\"\"\"\nFun\u00e7\u00f5es utilit\u00e1rias gen\u00e9ricas\n\"\"\"\nimport numpy as np\nfrom typing import Any, Dict, List, Optional\nfrom datetime import datetime, timedelta\nfrom trade_system.logging_config import logging.getLogger\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\ndef calculate_atr(\n    high: np.ndarray,\n    low: np.ndarray,\n    close: np.ndarray,\n    period: int = 14\n) -> np.ndarray:\n    \"\"\"\n    Calcula o ATR (Average True Range)\n    \n    Args:\n        high: Array de pre\u00e7os m\u00e1ximos\n        low: Array de pre\u00e7os m\u00ednimos\n        close: Array de pre\u00e7os de fechamento\n        period: Per\u00edodo para c\u00e1lculo da m\u00e9dia\n        \n    Returns:\n        Array com valores de ATR\n    \"\"\"\n    if len(close) < 2:\n        return np.full_like(close, np.nan)\n    \n    # True Range\n    tr = np.maximum(\n        high[1:] - low[1:],\n        np.maximum(\n            np.abs(high[1:] - close[:-1]),\n            np.abs(low[1:] - close[:-1])\n        )\n    )\n    \n    # M\u00e9dia m\u00f3vel simples do TR\n    if len(tr) >= period:\n        atr = np.convolve(tr, np.ones(period)/period, mode='valid')\n        # Padronizar para o mesmo tamanho de close\n        return np.concatenate([np.full(len(close) - len(atr), np.nan), atr])\n    else:\n        return np.full_like(close, np.nan)\n\n\ndef calculate_atr_from_prices(\n    prices: np.ndarray,\n    period: int = 14,\n    volatility_factor: float = 0.5\n) -> Optional[float]:\n    \"\"\"\n    Calcula ATR aproximado usando apenas pre\u00e7os de fechamento\n    \n    Args:\n        prices: Array de pre\u00e7os\n        period: Per\u00edodo para c\u00e1lculo\n        volatility_factor: Fator para aproximar high/low\n        \n    Returns:\n        Valor ATR aproximado ou None\n    \"\"\"\n    if len(prices) < period:\n        return None\n    \n    # Aproximar high/low usando volatilidade\n    volatility = np.std(prices[-period:])\n    \n    # Criar pseudo-OHLC\n    high = prices + volatility * volatility_factor\n    low = prices - volatility * volatility_factor\n    close = prices\n    \n    # Calcular ATR\n    atr_values = calculate_atr(high, low, close, period)\n    \n    # Retornar \u00faltimo valor v\u00e1lido\n    if len(atr_values) > 0 and not np.isnan(atr_values[-1]):\n        return float(atr_values[-1])\n    \n    # Fallback: usar volatilidade * fator\n    return volatility * 1.5\n\n\ndef format_price(price: float, decimals: int = 2) -> str:\n    \"\"\"Formata pre\u00e7o com separadores de milhares\"\"\"\n    return f\"${price:,.{decimals}f}\"\n\n\ndef format_percentage(value: float, decimals: int = 2) -> str:\n    \"\"\"Formata percentual com sinal\"\"\"\n    return f\"{value*100:+.{decimals}f}%\"\n\n\ndef calculate_position_metrics(\n    entry_price: float,\n    current_price: float,\n    quantity: float,\n    side: str,\n    fees: float = 0\n) -> Dict[str, float]:\n    \"\"\"\n    Calcula m\u00e9tricas de uma posi\u00e7\u00e3o\n    \n    Returns:\n        Dict com pnl, pnl_pct, value, etc\n    \"\"\"\n    if side == 'BUY':\n        pnl = (current_price - entry_price) * quantity\n        pnl_pct = (current_price - entry_price) / entry_price\n    else:  # SELL\n        pnl = (entry_price - current_price) * quantity\n        pnl_pct = (entry_price - current_price) / entry_price\n    \n    pnl_after_fees = pnl - fees\n    current_value = current_price * quantity\n    \n    return {\n        'pnl': pnl,\n        'pnl_after_fees': pnl_after_fees,\n        'pnl_pct': pnl_pct,\n        'current_value': current_value,\n        'fees': fees\n    }\n\n\ndef calculate_sharpe_ratio(\n    returns: np.ndarray,\n    periods_per_year: int = 252\n) -> float:\n    \"\"\"\n    Calcula Sharpe Ratio\n    \n    Args:\n        returns: Array de retornos\n        periods_per_year: 252 para daily, 52 para weekly, etc\n        \n    Returns:\n        Sharpe Ratio anualizado\n    \"\"\"\n    if len(returns) < 2:\n        return 0.0\n    \n    mean_return = np.mean(returns)\n    std_return = np.std(returns)\n    \n    if std_return == 0:\n        return 0.0\n    \n    return np.sqrt(periods_per_year) * mean_return / std_return\n\n\ndef calculate_max_drawdown(equity_curve: List[float]) -> float:\n    \"\"\"\n    Calcula drawdown m\u00e1ximo\n    \n    Args:\n        equity_curve: Lista de valores de equity\n        \n    Returns:\n        Drawdown m\u00e1ximo como percentual (0-1)\n    \"\"\"\n    if len(equity_curve) < 2:\n        return 0.0\n    \n    peak = equity_curve[0]\n    max_dd = 0.0\n    \n    for value in equity_curve[1:]:\n        if value > peak:\n            peak = value\n        else:\n            dd = (peak - value) / peak\n            max_dd = max(max_dd, dd)\n    \n    return max_dd\n\n\ndef is_market_open() -> bool:\n    \"\"\"Verifica se o mercado crypto est\u00e1 operacional (sempre True)\"\"\"\n    return True\n\n\ndef get_time_until_next_candle(interval_minutes: int = 5) -> int:\n    \"\"\"\n    Calcula segundos at\u00e9 pr\u00f3ximo candle\n    \n    Args:\n        interval_minutes: Intervalo do candle em minutos\n        \n    Returns:\n        Segundos at\u00e9 pr\u00f3ximo candle\n    \"\"\"\n    now = datetime.now()\n    current_minutes = now.minute\n    minutes_in_interval = current_minutes % interval_minutes\n    minutes_until_next = interval_minutes - minutes_in_interval\n    \n    return minutes_until_next * 60 - now.second\n\n\ndef validate_price_data(prices: np.ndarray) -> bool:\n    \"\"\"\n    Valida array de pre\u00e7os\n    \n    Returns:\n        True se dados s\u00e3o v\u00e1lidos\n    \"\"\"\n    if len(prices) == 0:\n        return False\n    \n    if np.any(prices <= 0):\n        return False\n    \n    if np.any(np.isnan(prices)) or np.any(np.isinf(prices)):\n        return False\n    \n    # Verificar varia\u00e7\u00e3o m\u00ednima\n    if np.std(prices) == 0:\n        return False\n    \n    return True\n\n\ndef safe_divide(numerator: float, denominator: float, default: float = 0.0) -> float:\n    \"\"\"Divis\u00e3o segura com valor padr\u00e3o\"\"\"\n    if denominator == 0:\n        return default\n    return numerator / denominator\n\n\ndef clamp(value: float, min_value: float, max_value: float) -> float:\n    \"\"\"Limita valor entre min e max\"\"\"\n    return max(min_value, min(value, max_value))\n"
    },
    "trade_system/validation.py": {
      "imports": [
        [
          "datetime",
          "datetime"
        ],
        [
          "typing",
          "Dict, List, Tuple"
        ]
      ],
      "classes": [
        "MarketConditionValidator"
      ],
      "content": "\"\"\"\nValida\u00e7\u00e3o das condi\u00e7\u00f5es de mercado com base em volatilidade, spread, volume e hor\u00e1rio\n\"\"\"\nimport time\nimport numpy as np\nfrom datetime import datetime\nfrom typing import Dict, List, Tuple\n\nclass MarketConditionValidator:\n    def __init__(self, config):\n        self.config = config\n        self.score = 100.0\n        self.reasons: List[str] = []\n        self.last_check = 0.0\n        self.check_interval = getattr(config, \"market_check_interval_s\", 60)\n        self.vol_history: List[float] = []\n        self.spread_history: List[float] = []\n\n    async def validate(self, data: Dict) -> Tuple[bool, List[str]]:\n        if self.config.debug_mode:\n            return True, []\n\n        self.score = 100.0\n        self.reasons.clear()\n\n        # Volatilidade\n        prices = data.get(\"prices\", [])\n        if len(prices) >= 100:\n            vol = float(np.std(prices[-100:]) / np.mean(prices[-100:]))\n            self.vol_history.append(vol)\n            if vol > self.config.max_volatility:\n                self.reasons.append(f\"Volatilidade alta: {vol:.2%}\")\n                self.score -= 25\n            elif vol > 0.8 * self.config.max_volatility:\n                self.reasons.append(f\"Volatilidade elevada: {vol:.2%}\")\n                self.score -= 15\n\n        # Spread\n        asks = data.get(\"orderbook_asks\", [])\n        bids = data.get(\"orderbook_bids\", [])\n        if asks and bids and asks[0][0] > 0 and bids[0][0] > 0:\n            spread_bps = (asks[0][0] - bids[0][0]) / bids[0][0] * 10000\n            self.spread_history.append(spread_bps)\n            if spread_bps > self.config.max_spread_bps:\n                self.reasons.append(f\"Spread alto: {spread_bps:.1f} bps\")\n                self.score -= 25\n            elif spread_bps > 0.8 * self.config.max_spread_bps:\n                self.reasons.append(f\"Spread elevado: {spread_bps:.1f} bps\")\n                self.score -= 10\n\n        # Hor\u00e1rio\n        hour = datetime.utcnow().hour\n        if 2 <= hour <= 6:\n            self.reasons.append(\"Hor\u00e1rio de baixa liquidez (2h-6h UTC)\")\n            self.score -= 10\n        if datetime.utcnow().weekday() == 6:\n            self.reasons.append(\"Domingo - mercado fraco\")\n            self.score -= 10\n\n        is_safe = self.score >= getattr(self.config, \"min_market_score\", 50)\n        return is_safe, self.reasons\n"
    },
    "trade_system/websocket_manager.py": {
      "imports": [
        [
          "collections",
          "deque"
        ],
        [
          "datetime",
          "datetime"
        ],
        [
          "typing",
          "Dict, List, Optional, Any"
        ]
      ],
      "classes": [
        "WebSocketManager"
      ],
      "content": "\"\"\"WebSocket Manager para conex\u00e3o em tempo real\"\"\"\nimport asyncio\nimport json\nimport logging\nfrom collections import deque\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Any\nimport aiohttp\nimport pandas as pd\n\nclass WebSocketManager:\n    \"\"\"Gerencia conex\u00f5es WebSocket com a Binance\"\"\"\n    \n    def __init__(self, config: Any):\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        self.symbol = getattr(config, 'symbol', 'BTCUSDT').lower()\n        \n        # Buffers\n        self.price_buffer = deque(maxlen=1000)\n        self.trade_buffer = deque(maxlen=1000)\n        self.orderbook_buffer = deque(maxlen=100)\n        \n        # Estado\n        self.is_connected = False\n        self.ws = None\n        \n        self.logger.info(\"\ud83d\udce1 WebSocket Manager inicializado\")\n    \n    async def connect(self):\n        \"\"\"Conecta ao WebSocket da Binance\"\"\"\n        # Por enquanto, usar REST API com polling\n        self.is_connected = True\n        self.logger.info(\"\u2705 WebSocket simulado conectado\")\n        \n        # Iniciar task de polling\n        asyncio.create_task(self._polling_loop())\n    \n    async def disconnect(self):\n        \"\"\"Desconecta WebSocket\"\"\"\n        self.is_connected = False\n        self.logger.info(\"WebSocket desconectado\")\n    \n    async def _polling_loop(self):\n        \"\"\"Loop de polling para simular WebSocket\"\"\"\n        while self.is_connected:\n            try:\n                async with aiohttp.ClientSession() as session:\n                    # Buscar pre\u00e7o atual\n                    url = f\"https://api.binance.com/api/v3/ticker/price?symbol={self.symbol.upper()}\"\n                    async with session.get(url) as resp:\n                        if resp.status == 200:\n                            data = await resp.json()\n                            price_data = {\n                                'close': float(data['price']),\n                                'time': datetime.now(),\n                                'symbol': data['symbol']\n                            }\n                            self.price_buffer.append(price_data)\n                \n                await asyncio.sleep(5)  # Polling a cada 5 segundos\n                \n            except Exception as e:\n                self.logger.error(f\"Erro no polling: {e}\")\n                await asyncio.sleep(10)\n    \n    def get_latest_price(self) -> Optional[float]:\n        \"\"\"Retorna \u00faltimo pre\u00e7o\"\"\"\n        if self.price_buffer:\n            return self.price_buffer[-1]['close']\n        return None\n    \n    def get_latest_orderbook(self) -> Optional[Dict]:\n        \"\"\"Retorna \u00faltimo orderbook\"\"\"\n        # Simulado por enquanto\n        if self.orderbook_buffer:\n            return self.orderbook_buffer[-1]\n        \n        # Orderbook fake para testes\n        return {\n            'bids': [[str(self.get_latest_price() or 50000 - i*10), str(1.0/(i+1))] for i in range(10)],\n            'asks': [[str(self.get_latest_price() or 50000 + i*10), str(1.0/(i+1))] for i in range(10)],\n            'timestamp': datetime.now().timestamp()\n        }\n    \n    def get_candles_df(self, limit: int = 100) -> Optional[pd.DataFrame]:\n        \"\"\"Retorna DataFrame com candles\"\"\"\n        if len(self.price_buffer) < 2:\n            return None\n        \n        # Criar DataFrame simples\n        data = list(self.price_buffer)[-limit:]\n        df = pd.DataFrame(data)\n        \n        # Adicionar colunas necess\u00e1rias\n        if 'close' in df.columns:\n            df['open'] = df['close'].shift(1).fillna(df['close'])\n            df['high'] = df['close'] * 1.001\n            df['low'] = df['close'] * 0.999\n            df['volume'] = 1000.0\n        \n        return df\n    \n    def get_market_metrics(self) -> Dict[str, float]:\n        \"\"\"Calcula m\u00e9tricas de mercado\"\"\"\n        return {\n            'buy_volume_ratio': 0.5,\n            'sell_volume_ratio': 0.5,\n            'vwap': self.get_latest_price() or 0,\n            'trade_count': len(self.trade_buffer)\n        }\n"
    },
    "trade_system/__init__.py": {
      "imports": [
        [
          "trade_system.config",
          "TradingConfig"
        ],
        [
          "trade_system.main",
          "TradingSystem, run_paper_trading"
        ]
      ],
      "classes": [],
      "content": "\"\"\"Ultra Trading System - Bot de trading algor\u00edtmico de alta performance\"\"\"\n\n__version__ = \"2.0.0\"\n__author__ = \"Alexandre Figura\"\n\nfrom trade_system.config import TradingConfig\nfrom trade_system.main import TradingSystem, run_paper_trading\n\n__all__ = ['TradingConfig', 'TradingSystem', 'run_paper_trading']\n"
    },
    "trade_system/analysis/ml.py": {
      "imports": [
        [
          "sklearn.ensemble",
          "RandomForestClassifier, GradientBoostingClassifier"
        ],
        [
          "sklearn.model_selection",
          "train_test_split, cross_val_score"
        ],
        [
          "sklearn.preprocessing",
          "StandardScaler"
        ],
        [
          "sklearn.metrics",
          "accuracy_score, precision_score, recall_score"
        ],
        [
          "typing",
          "Any, Dict, List, Optional, Tuple"
        ],
        [
          "pathlib",
          "Path"
        ]
      ],
      "classes": [
        "MLPredictor"
      ],
      "content": "\"\"\"Sistema de Machine Learning para predi\u00e7\u00e3o\"\"\"\nimport numpy as np\nimport pandas as pd\nfrom sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier\nfrom sklearn.model_selection import train_test_split, cross_val_score\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score\nimport joblib\nimport logging\nfrom typing import Any, Dict, List, Optional, Tuple\nfrom pathlib import Path\n\nclass MLPredictor:\n    \"\"\"Preditor ML avan\u00e7ado para trading\"\"\"\n    \n    def __init__(self, config: Any):\n        self.config = config.ml if hasattr(config, 'ml') else config.get('ml', {})\n        self.logger = logging.getLogger(__name__)\n        \n        # Modelos\n        self.model = None\n        self.scaler = StandardScaler()\n        \n        # Features\n        self.feature_names = self.config.get('features', [\n            'rsi', 'macd', 'macd_signal', 'bb_upper', 'bb_lower', \n            'bb_middle', 'volume_ratio', 'price_change', 'volatility',\n            'momentum', 'support', 'resistance', 'trend_strength',\n            'volume_profile', 'ema_diff', 'atr'\n        ])\n        \n        # Estado\n        self.is_trained = False\n        self.model_path = Path(\"models\")\n        self.model_path.mkdir(exist_ok=True)\n        \n        # M\u00e9tricas\n        self.training_metrics = {}\n        \n        self.logger.info(\"\ud83e\udd16 ML Predictor inicializado\")\n    \n    def prepare_features(self, candles: pd.DataFrame, \n                        ta_indicators: Dict[str, float]) -> np.ndarray:\n        \"\"\"\n        Prepara features para o modelo\n        \n        Args:\n            candles: DataFrame com dados OHLCV\n            ta_indicators: Indicadores t\u00e9cnicos calculados\n            \n        Returns:\n            Array de features normalizado\n        \"\"\"\n        features = []\n        \n        for feature_name in self.feature_names:\n            if feature_name in ta_indicators:\n                value = ta_indicators[feature_name]\n                if isinstance(value, (int, float)) and not np.isnan(value):\n                    features.append(value)\n                else:\n                    self.logger.warning(f\"Feature ausente: {feature_name}\")\n                    features.append(0.0)\n            else:\n                features.append(0.0)\n        \n        return np.array(features).reshape(1, -1)\n    \n    def train(self, candles: pd.DataFrame, ta_analyzer: Any):\n        \"\"\"\n        Treina o modelo com dados hist\u00f3ricos\n        \n        Args:\n            candles: DataFrame com dados hist\u00f3ricos\n            ta_analyzer: Analisador t\u00e9cnico para extrair features\n        \"\"\"\n        try:\n            self.logger.info(\"\ud83d\udd04 Iniciando treinamento do modelo ML...\")\n            \n            # Preparar dataset\n            X, y = self._prepare_training_data(candles, ta_analyzer)\n            \n            if len(X) < 100:\n                self.logger.warning(\"Dados insuficientes para treinar ML\")\n                return\n            \n            # Normalizar features\n            X_scaled = self.scaler.fit_transform(X)\n            \n            # Split treino/teste\n            test_size = self.config.get('test_size', 0.2)\n            X_train, X_test, y_train, y_test = train_test_split(\n                X_scaled, y, test_size=test_size, random_state=42, stratify=y\n            )\n            \n            # Treinar modelo ensemble\n            self.model = self._create_ensemble_model()\n            self.model.fit(X_train, y_train)\n            \n            # Avaliar modelo\n            self._evaluate_model(X_test, y_test)\n            \n            # Salvar modelo\n            self._save_model()\n            \n            self.is_trained = True\n            self.logger.info(\"\u2705 Modelo ML treinado com sucesso!\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erro ao treinar ML: {e}\")\n            self.is_trained = False\n    \n    def _prepare_training_data(self, candles: pd.DataFrame, \n                              ta_analyzer: Any) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Prepara dados para treinamento\"\"\"\n        lookback = self.config.get('lookback', 100)\n        X = []\n        y = []\n        \n        for i in range(lookback, len(candles) - 1):\n            # Analisar per\u00edodo\n            period_candles = candles.iloc[i-lookback:i].copy()\n            analysis = ta_analyzer.analyze(period_candles)\n            \n            if analysis['indicators']:\n                # Extrair features\n                features = self.prepare_features(period_candles, analysis['indicators'])\n                X.append(features[0])\n                \n                # Criar label (1 = pre\u00e7o sobe, 0 = pre\u00e7o desce)\n                current_price = candles.iloc[i]['close']\n                future_price = candles.iloc[i+1]['close']\n                \n                # Considerar movimento significativo (> 0.1%)\n                price_change = (future_price - current_price) / current_price\n                y.append(1 if price_change > 0.001 else 0)\n        \n        return np.array(X), np.array(y)\n    \n    def _create_ensemble_model(self):\n        \"\"\"Cria modelo ensemble\"\"\"\n        model_type = self.config.get('model_type', 'gradient_boosting')\n        n_estimators = self.config.get('n_estimators', 100)\n        \n        if model_type == 'gradient_boosting':\n            return GradientBoostingClassifier(\n                n_estimators=n_estimators,\n                learning_rate=0.1,\n                max_depth=3,\n                random_state=42,\n                subsample=0.8,\n                min_samples_split=5\n            )\n        else:  # random_forest\n            return RandomForestClassifier(\n                n_estimators=n_estimators,\n                max_depth=5,\n                random_state=42,\n                min_samples_split=5,\n                class_weight='balanced'\n            )\n    \n    def _evaluate_model(self, X_test: np.ndarray, y_test: np.ndarray):\n        \"\"\"Avalia performance do modelo\"\"\"\n        y_pred = self.model.predict(X_test)\n        \n        self.training_metrics = {\n            'accuracy': accuracy_score(y_test, y_pred),\n            'precision': precision_score(y_test, y_pred, zero_division=0),\n            'recall': recall_score(y_test, y_pred, zero_division=0),\n            'samples': len(y_test)\n        }\n        \n        # Feature importance\n        if hasattr(self.model, 'feature_importances_'):\n            importances = self.model.feature_importances_\n            feature_importance = dict(zip(self.feature_names, importances))\n            top_features = sorted(feature_importance.items(), \n                                key=lambda x: x[1], reverse=True)[:5]\n            \n            self.logger.info(\"Top 5 features:\")\n            for feature, importance in top_features:\n                self.logger.info(f\"  - {feature}: {importance:.3f}\")\n        \n        self.logger.info(f\"M\u00e9tricas do modelo:\")\n        self.logger.info(f\"  - Acur\u00e1cia: {self.training_metrics['accuracy']:.2%}\")\n        self.logger.info(f\"  - Precis\u00e3o: {self.training_metrics['precision']:.2%}\")\n        self.logger.info(f\"  - Recall: {self.training_metrics['recall']:.2%}\")\n    \n    def predict(self, features: np.ndarray) -> Tuple[str, float]:\n        \"\"\"\n        Faz predi\u00e7\u00e3o com o modelo treinado\n        \n        Args:\n            features: Features normalizadas\n            \n        Returns:\n            Tuple (sinal, confian\u00e7a)\n        \"\"\"\n        if not self.is_trained or self.model is None:\n            return 'HOLD', 0.0\n        \n        try:\n            # Normalizar features\n            features_scaled = self.scaler.transform(features)\n            \n            # Predi\u00e7\u00e3o com probabilidade\n            prediction = self.model.predict(features_scaled)[0]\n            probabilities = self.model.predict_proba(features_scaled)[0]\n            \n            # Confian\u00e7a \u00e9 a probabilidade da classe predita\n            confidence = max(probabilities)\n            \n            # Ajustar threshold baseado nas m\u00e9tricas de treinamento\n            threshold = 0.6\n            if self.training_metrics.get('accuracy', 0) < 0.55:\n                threshold = 0.7  # Mais conservador se acur\u00e1cia baixa\n            \n            if prediction == 1 and confidence > threshold:\n                return 'BUY', confidence\n            elif prediction == 0 and confidence > threshold:\n                return 'SELL', confidence\n            else:\n                return 'HOLD', confidence\n            \n        except Exception as e:\n            self.logger.error(f\"Erro na predi\u00e7\u00e3o ML: {e}\")\n            return 'HOLD', 0.0\n    \n    def _save_model(self):\n        \"\"\"Salva modelo treinado\"\"\"\n        try:\n            model_file = self.model_path / \"trading_model.pkl\"\n            scaler_file = self.model_path / \"scaler.pkl\"\n            \n            joblib.dump(self.model, model_file)\n            joblib.dump(self.scaler, scaler_file)\n            \n            # Salvar m\u00e9tricas\n            metrics_file = self.model_path / \"metrics.json\"\n            import json\n            with open(metrics_file, 'w') as f:\n                json.dump(self.training_metrics, f, indent=2)\n            \n            self.logger.info(f\"Modelo salvo em: {model_file}\")\n            \n        except Exception as e:\n            self.logger.error(f\"Erro ao salvar modelo: {e}\")\n    \n    def load_model(self) -> bool:\n        \"\"\"Carrega modelo salvo\"\"\"\n        try:\n            model_file = self.model_path / \"trading_model.pkl\"\n            scaler_file = self.model_path / \"scaler.pkl\"\n            \n            if model_file.exists() and scaler_file.exists():\n                self.model = joblib.load(model_file)\n                self.scaler = joblib.load(scaler_file)\n                self.is_trained = True\n                \n                self.logger.info(\"\u2705 Modelo carregado com sucesso\")\n                return True\n            \n            return False\n            \n        except Exception as e:\n            self.logger.error(f\"Erro ao carregar modelo: {e}\")\n            return False\n    \n    def should_retrain(self, trades_count: int) -> bool:\n        \"\"\"Verifica se deve retreinar o modelo\"\"\"\n        retrain_interval = self.config.get('retrain_interval', 1000)\n        return trades_count % retrain_interval == 0\n"
    },
    "trade_system/analysis/orderbook.py": {
      "imports": [
        [
          "typing",
          "Dict, Any, Optional, Tuple, List"
        ]
      ],
      "classes": [
        "OrderbookAnalyzer"
      ],
      "content": "\"\"\"An\u00e1lise do livro de ofertas (orderbook)\"\"\"\nimport numpy as np\nimport logging\nfrom typing import Dict, Any, Optional, Tuple, List\n\nclass OrderbookAnalyzer:\n    \"\"\"Analisa o livro de ofertas para detectar press\u00e3o de compra/venda\"\"\"\n    \n    def __init__(self, config: Any):\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        \n    def analyze(self, orderbook: Optional[Dict]) -> Dict[str, Any]:\n        \"\"\"\n        Analisa orderbook e retorna m\u00e9tricas\n        \n        Args:\n            orderbook: Dict com bids e asks\n            \n        Returns:\n            Dict com an\u00e1lise do orderbook\n        \"\"\"\n        if not orderbook:\n            return self._empty_analysis()\n        \n        try:\n            bids = orderbook.get('bids', [])\n            asks = orderbook.get('asks', [])\n            \n            if not bids or not asks:\n                return self._empty_analysis()\n            \n            # Converter para arrays numpy\n            bids = np.array(bids[:20], dtype=float)  # Top 20 bids\n            asks = np.array(asks[:20], dtype=float)  # Top 20 asks\n            \n            # Calcular m\u00e9tricas\n            metrics = {\n                **self._calculate_spread(bids, asks),\n                **self._calculate_pressure(bids, asks),\n                **self._calculate_imbalance(bids, asks)\n            }\n            \n            # Gerar sinal\n            signal = self._generate_signal(metrics)\n            metrics['signal'] = signal\n            \n            return metrics\n            \n        except Exception as e:\n            self.logger.error(f\"Erro ao analisar orderbook: {e}\")\n            return self._empty_analysis()\n    \n    def _calculate_spread(self, bids: np.ndarray, asks: np.ndarray) -> Dict[str, float]:\n        \"\"\"Calcula spread\"\"\"\n        best_bid = bids[0][0]\n        best_ask = asks[0][0]\n        \n        spread = best_ask - best_bid\n        spread_pct = (spread / best_bid) * 100\n        spread_bps = spread_pct * 100\n        \n        return {\n            'best_bid': best_bid,\n            'best_ask': best_ask,\n            'spread': spread,\n            'spread_pct': spread_pct,\n            'spread_bps': spread_bps\n        }\n    \n    def _calculate_pressure(self, bids: np.ndarray, asks: np.ndarray) -> Dict[str, float]:\n        \"\"\"Calcula press\u00e3o compradora/vendedora\"\"\"\n        bid_volume = np.sum(bids[:, 1])\n        ask_volume = np.sum(asks[:, 1])\n        total_volume = bid_volume + ask_volume\n        \n        buy_pressure = bid_volume / total_volume if total_volume > 0 else 0.5\n        \n        return {\n            'buy_pressure': buy_pressure,\n            'sell_pressure': 1 - buy_pressure,\n            'bid_volume': bid_volume,\n            'ask_volume': ask_volume\n        }\n    \n    def _calculate_imbalance(self, bids: np.ndarray, asks: np.ndarray) -> Dict[str, float]:\n        \"\"\"Calcula desequil\u00edbrio no topo do book\"\"\"\n        top_bid_vol = bids[0][1]\n        top_ask_vol = asks[0][1]\n        \n        total = top_bid_vol + top_ask_vol\n        imbalance = (top_bid_vol - top_ask_vol) / total if total > 0 else 0\n        \n        return {\n            'imbalance': imbalance,\n            'top_bid_volume': top_bid_vol,\n            'top_ask_volume': top_ask_vol\n        }\n    \n    def _generate_signal(self, metrics: Dict[str, float]) -> str:\n        \"\"\"Gera sinal baseado nas m\u00e9tricas\"\"\"\n        buy_pressure = metrics.get('buy_pressure', 0.5)\n        imbalance = metrics.get('imbalance', 0)\n        \n        if buy_pressure > 0.65 and imbalance > 0.2:\n            return 'STRONG_BUY'\n        elif buy_pressure > 0.55:\n            return 'BUY'\n        elif buy_pressure < 0.35 and imbalance < -0.2:\n            return 'STRONG_SELL'\n        elif buy_pressure < 0.45:\n            return 'SELL'\n        else:\n            return 'NEUTRAL'\n    \n    def _empty_analysis(self) -> Dict[str, Any]:\n        \"\"\"Retorna an\u00e1lise vazia\"\"\"\n        return {\n            'buy_pressure': 0.5,\n            'sell_pressure': 0.5,\n            'spread_bps': 0,\n            'imbalance': 0,\n            'signal': 'NEUTRAL'\n        }\n"
    },
    "trade_system/analysis/technical.py": {
      "imports": [
        [
          "numba",
          "jit, prange"
        ],
        [
          "typing",
          "Any, Dict, Optional, Tuple"
        ]
      ],
      "classes": [
        "TechnicalAnalyzer"
      ],
      "content": "\"\"\"An\u00e1lise t\u00e9cnica otimizada com Numba\"\"\"\nimport numpy as np\nimport pandas as pd\nimport talib\nfrom numba import jit, prange\nimport logging\nfrom typing import Any, Dict, Optional, Tuple\n\n@jit(nopython=True)\ndef calculate_rsi_fast(prices: np.ndarray, period: int = 14) -> np.ndarray:\n    \"\"\"RSI otimizado com Numba para performance m\u00e1xima\"\"\"\n    if len(prices) < period + 1:\n        return np.full_like(prices, 50.0)\n    \n    deltas = np.diff(prices)\n    seed = deltas[:period+1]\n    up = seed[seed >= 0].sum() / period\n    down = -seed[seed < 0].sum() / period\n    \n    if down == 0:\n        rs = 100\n    else:\n        rs = up / down\n    \n    rsi = np.zeros_like(prices)\n    rsi[:period] = np.nan\n    rsi[period] = 100. - 100. / (1. + rs)\n    \n    for i in range(period + 1, len(prices)):\n        delta = deltas[i - 1]\n        if delta > 0:\n            upval = delta\n            downval = 0.\n        else:\n            upval = 0.\n            downval = -delta\n        \n        up = (up * (period - 1) + upval) / period\n        down = (down * (period - 1) + downval) / period\n        \n        if down == 0:\n            rs = 100\n        else:\n            rs = up / down\n            \n        rsi[i] = 100. - 100. / (1. + rs)\n    \n    return rsi\n\n@jit(nopython=True)\ndef calculate_bollinger_bands_fast(prices: np.ndarray, period: int = 20, \n                                  std_dev: float = 2.0) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Bollinger Bands otimizado com Numba\"\"\"\n    middle = np.zeros_like(prices)\n    upper = np.zeros_like(prices)\n    lower = np.zeros_like(prices)\n    \n    for i in range(period - 1, len(prices)):\n        slice_prices = prices[i - period + 1:i + 1]\n        mean = np.mean(slice_prices)\n        std = np.std(slice_prices)\n        \n        middle[i] = mean\n        upper[i] = mean + (std_dev * std)\n        lower[i] = mean - (std_dev * std)\n    \n    return upper, middle, lower\n\n@jit(nopython=True)\ndef calculate_support_resistance_fast(highs: np.ndarray, lows: np.ndarray, \n                                    lookback: int = 20) -> Tuple[float, float]:\n    \"\"\"Calcula suporte e resist\u00eancia de forma otimizada\"\"\"\n    if len(highs) < lookback:\n        return lows[-1], highs[-1]\n    \n    recent_lows = lows[-lookback:]\n    recent_highs = highs[-lookback:]\n    \n    # M\u00e9todo simples mas eficaz\n    support = np.percentile(recent_lows, 25)\n    resistance = np.percentile(recent_highs, 75)\n    \n    return support, resistance\n\nclass TechnicalAnalyzer:\n    \"\"\"An\u00e1lise t\u00e9cnica de alta performance\"\"\"\n    \n    def __init__(self, config: Any):\n        self.config = config.ta if hasattr(config, 'ta') else config.get('ta', {})\n        self.logger = logging.getLogger(__name__)\n        self.indicators_cache = {}\n        \n    def analyze(self, candles: pd.DataFrame) -> Dict[str, Any]:\n        \"\"\"\n        An\u00e1lise t\u00e9cnica completa\n        \n        Args:\n            candles: DataFrame com OHLCV\n            \n        Returns:\n            Dict com sinal, confian\u00e7a e indicadores\n        \"\"\"\n        try:\n            if len(candles) < 50:\n                return self._empty_analysis()\n            \n            # Extrair arrays numpy para performance\n            close = candles['close'].values\n            high = candles['high'].values\n            low = candles['low'].values\n            volume = candles['volume'].values\n            \n            # Calcular todos os indicadores\n            indicators = self._calculate_indicators(close, high, low, volume)\n            \n            # Gerar sinal baseado nos indicadores\n            signal, confidence = self._generate_signal(indicators, close[-1])\n            \n            self.logger.info(f\"\ud83d\udcca TA Sinal: {signal} (conf {confidence:.2%})\")\n            \n            return {\n                'signal': signal,\n                'confidence': confidence,\n                'indicators': indicators,\n                'price': close[-1]\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Erro na an\u00e1lise t\u00e9cnica: {e}\")\n            return self._empty_analysis()\n    \n    def _calculate_indicators(self, close: np.ndarray, high: np.ndarray, \n                            low: np.ndarray, volume: np.ndarray) -> Dict[str, float]:\n        \"\"\"Calcula todos os indicadores t\u00e9cnicos\"\"\"\n        indicators = {}\n        \n        # RSI\n        rsi_period = self.config.get('rsi_period', 14)\n        indicators['rsi'] = calculate_rsi_fast(close, rsi_period)[-1]\n        \n        # MACD\n        macd_fast = self.config.get('macd_fast', 12)\n        macd_slow = self.config.get('macd_slow', 26)\n        macd_signal = self.config.get('macd_signal', 9)\n        \n        macd_line, signal_line, macd_hist = talib.MACD(\n            close, fastperiod=macd_fast, slowperiod=macd_slow, signalperiod=macd_signal\n        )\n        indicators['macd'] = macd_line[-1] if not np.isnan(macd_line[-1]) else 0\n        indicators['macd_signal'] = signal_line[-1] if not np.isnan(signal_line[-1]) else 0\n        indicators['macd_hist'] = macd_hist[-1] if not np.isnan(macd_hist[-1]) else 0\n        \n        # Bollinger Bands\n        bb_period = self.config.get('bb_period', 20)\n        bb_std = self.config.get('bb_std', 2.0)\n        bb_upper, bb_middle, bb_lower = calculate_bollinger_bands_fast(close, bb_period, bb_std)\n        \n        indicators['bb_upper'] = bb_upper[-1]\n        indicators['bb_middle'] = bb_middle[-1]\n        indicators['bb_lower'] = bb_lower[-1]\n        indicators['bb_width'] = (bb_upper[-1] - bb_lower[-1]) / bb_middle[-1]\n        \n        # EMAs\n        ema_short = self.config.get('ema_short', 9)\n        ema_long = self.config.get('ema_long', 21)\n        indicators['ema_short'] = talib.EMA(close, timeperiod=ema_short)[-1]\n        indicators['ema_long'] = talib.EMA(close, timeperiod=ema_long)[-1]\n        indicators['ema_diff'] = (indicators['ema_short'] - indicators['ema_long']) / indicators['ema_long']\n        \n        # Momentum (feature importante que estava faltando!)\n        momentum_period = self.config.get('momentum_period', 10)\n        indicators['momentum'] = talib.MOM(close, timeperiod=momentum_period)[-1]\n        \n        # ATR (Volatilidade)\n        atr_period = self.config.get('atr_period', 14)\n        indicators['atr'] = talib.ATR(high, low, close, timeperiod=atr_period)[-1]\n        indicators['volatility'] = indicators['atr'] / close[-1]\n        \n        # Support & Resistance\n        support, resistance = calculate_support_resistance_fast(high, low)\n        indicators['support'] = support\n        indicators['resistance'] = resistance\n        \n        # Volume indicators\n        indicators['volume_ratio'] = volume[-1] / np.mean(volume[-20:])\n        indicators['volume_sma'] = np.mean(volume[-20:])\n        \n        # Price action\n        indicators['price_change'] = (close[-1] - close[-2]) / close[-2]\n        indicators['high_low_ratio'] = (high[-1] - low[-1]) / close[-1]\n        \n        # Trend strength\n        indicators['trend_strength'] = self._calculate_trend_strength(close)\n        \n        # Volume profile\n        indicators['volume_profile'] = self._calculate_volume_profile(volume, close)\n        \n        return indicators\n    \n    def _calculate_trend_strength(self, prices: np.ndarray) -> float:\n        \"\"\"Calcula for\u00e7a da tend\u00eancia usando regress\u00e3o linear\"\"\"\n        if len(prices) < 20:\n            return 0.5\n        \n        # Usar \u00faltimos 20 per\u00edodos\n        y = prices[-20:]\n        x = np.arange(len(y))\n        \n        # Regress\u00e3o linear simples\n        slope = np.polyfit(x, y, 1)[0]\n        \n        # Normalizar pela volatilidade\n        normalized_slope = np.tanh(slope / np.std(y) * 10)\n        \n        # Converter para 0-1\n        return (normalized_slope + 1) / 2\n    \n    def _calculate_volume_profile(self, volume: np.ndarray, prices: np.ndarray) -> float:\n        \"\"\"Calcula perfil de volume (VWAP simplificado)\"\"\"\n        if len(volume) < 20:\n            return 0.5\n        \n        # VWAP dos \u00faltimos 20 per\u00edodos\n        vwap = np.sum(volume[-20:] * prices[-20:]) / np.sum(volume[-20:])\n        current_price = prices[-1]\n        \n        # Diferen\u00e7a normalizada\n        diff = (current_price - vwap) / vwap\n        \n        # Converter para score 0-1\n        return np.tanh(diff * 100) / 2 + 0.5\n    \n    def _generate_signal(self, indicators: Dict[str, float], current_price: float) -> Tuple[str, float]:\n        \"\"\"Gera sinal de trading baseado nos indicadores\"\"\"\n        buy_score = 0\n        sell_score = 0\n        total_weight = 0\n        \n        # RSI\n        rsi = indicators['rsi']\n        rsi_buy = self.config.get('rsi_buy_threshold', 30)\n        rsi_sell = self.config.get('rsi_sell_threshold', 70)\n        \n        if rsi < rsi_buy:\n            buy_score += 0.25\n        elif rsi > rsi_sell:\n            sell_score += 0.25\n        total_weight += 0.25\n        \n        # MACD\n        if indicators['macd'] > indicators['macd_signal'] and indicators['macd'] < 0:\n            buy_score += 0.20\n        elif indicators['macd'] < indicators['macd_signal'] and indicators['macd'] > 0:\n            sell_score += 0.20\n        total_weight += 0.20\n        \n        # Bollinger Bands\n        if current_price < indicators['bb_lower']:\n            buy_score += 0.15\n        elif current_price > indicators['bb_upper']:\n            sell_score += 0.15\n        total_weight += 0.15\n        \n        # EMA Cross\n        if indicators['ema_diff'] > 0.001:\n            buy_score += 0.15\n        elif indicators['ema_diff'] < -0.001:\n            sell_score += 0.15\n        total_weight += 0.15\n        \n        # Momentum\n        if indicators['momentum'] > 0:\n            buy_score += 0.10\n        else:\n            sell_score += 0.10\n        total_weight += 0.10\n        \n        # Trend\n        trend = indicators['trend_strength']\n        if trend > 0.6:\n            buy_score += 0.10\n        elif trend < 0.4:\n            sell_score += 0.10\n        total_weight += 0.10\n        \n        # Volume\n        if indicators['volume_ratio'] > 1.5 and indicators['price_change'] > 0:\n            buy_score += 0.05\n        elif indicators['volume_ratio'] > 1.5 and indicators['price_change'] < 0:\n            sell_score += 0.05\n        total_weight += 0.05\n        \n        # Calcular confian\u00e7a final\n        buy_confidence = buy_score / total_weight if total_weight > 0 else 0\n        sell_confidence = sell_score / total_weight if total_weight > 0 else 0\n        \n        # Determinar sinal\n        if buy_confidence > sell_confidence and buy_confidence > 0.5:\n            return 'BUY', buy_confidence\n        elif sell_confidence > buy_confidence and sell_confidence > 0.5:\n            return 'SELL', sell_confidence\n        else:\n            return 'HOLD', max(buy_confidence, sell_confidence)\n    \n    def _empty_analysis(self) -> Dict[str, Any]:\n        \"\"\"Retorna an\u00e1lise vazia em caso de erro\"\"\"\n        return {\n            'signal': 'HOLD',\n            'confidence': 0.0,\n            'indicators': {},\n            'price': 0.0\n        }\n"
    },
    "trade_system/analysis/__init__.py": {
      "imports": [
        [
          "trade_system.analysis.technical",
          "TechnicalAnalyzer"
        ],
        [
          "trade_system.analysis.orderbook",
          "OrderbookAnalyzer"
        ],
        [
          "trade_system.analysis.ml",
          "MLPredictor"
        ]
      ],
      "classes": [],
      "content": "\"\"\"M\u00f3dulos de an\u00e1lise\"\"\"\n\nfrom trade_system.analysis.technical import TechnicalAnalyzer\nfrom trade_system.analysis.orderbook import OrderbookAnalyzer\n\n__all__ = ['TechnicalAnalyzer', 'OrderbookAnalyzer']\n\n# Tentar importar ML se dispon\u00edvel\ntry:\n    from trade_system.analysis.ml import MLPredictor\n    __all__.append('MLPredictor')\nexcept ImportError:\n    pass\n"
    }
  },
  "classes": {
    "AlertManager": "trade_system/alerts.py",
    "Backtester": "trade_system/backtester.py",
    "CacheManager": "trade_system/cache.py",
    "CheckpointManager": "trade_system/checkpoint.py",
    "TradingConfig": "trade_system/config.py",
    "TradeLearning": "trade_system/learning.py",
    "TradingSystem": "trade_system/main.py",
    "PaperTrader": "trade_system/paper_trader.py",
    "RateLimiter": "trade_system/rate_limiter.py",
    "RiskManager": "trade_system/risk.py",
    "SignalAggregator": "trade_system/signals.py",
    "TradeLogger": "trade_system/trade_logger.py",
    "MarketConditionValidator": "trade_system/validation.py",
    "WebSocketManager": "trade_system/websocket_manager.py",
    "MLPredictor": "trade_system/analysis/ml.py",
    "OrderbookAnalyzer": "trade_system/analysis/orderbook.py",
    "TechnicalAnalyzer": "trade_system/analysis/technical.py"
  },
  "missing": [
    [
      "run_paper_trading",
      "trade_system/cli.py"
    ],
    [
      "setup_logging",
      "trade_system/main.py"
    ],
    [
      "SimplifiedMLPredictor",
      "trade_system/main.py"
    ],
    [
      "OptimizedSignalConsolidator",
      "trade_system/main.py"
    ],
    [
      "Position",
      "trade_system/main.py"
    ],
    [
      "setup_logging",
      "trade_system/cli.py"
    ],
    [
      "logging.getLogger",
      "trade_system/utils.py"
    ],
    [
      "run_paper_trading",
      "trade_system/__init__.py"
    ]
  ],
  "errors": [
    "Erro de sintaxe em trade_system\\utils.py: import logging.getLogger"
  ]
}